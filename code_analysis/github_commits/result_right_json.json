[{"repository": "apache/dubbo", "commit_sha": "16fc7b55ef20f97d2b5e7b983d4d10eb9afc4c82", "mongoId": "63e2018185d52e6dee102430", "fileName": "dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/stub/StubInvocationUtilTest.java", "oldFileContent": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.dubbo.rpc.stub;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.stream.StreamObserver;\nimport org.apache.dubbo.rpc.Invocation;\nimport org.apache.dubbo.rpc.Invoker;\nimport org.apache.dubbo.rpc.Result;\nimport org.apache.dubbo.rpc.model.ConsumerModel;\nimport org.apache.dubbo.rpc.model.MethodDescriptor;\nimport org.apache.dubbo.rpc.model.ServiceDescriptor;\nimport org.apache.dubbo.rpc.support.DemoService;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\n\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport static org.junit.jupiter.api.Assertions.fail;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.when;\n\nclass StubInvocationUtilTest {\n\n    @Test\n    void unaryCall() throws Throwable {\n        Invoker<DemoService> invoker = Mockito.mock(Invoker.class);\n        URL url = Mockito.mock(URL.class);\n        ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);\n        ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);\n        when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);\n        when(url.getServiceModel())\n            .thenReturn(consumerModel);\n        when(url.getServiceInterface())\n            .thenReturn(DemoService.class.getName());\n        when(url.getProtocolServiceKey())\n            .thenReturn(DemoService.class.getName());\n        when(invoker.getUrl())\n            .thenReturn(url);\n        when(invoker.getInterface())\n            .thenReturn(DemoService.class);\n        Result result = Mockito.mock(Result.class);\n        when(invoker.invoke(any(Invocation.class)))\n            .thenReturn(result);\n        String response = \"response\";\n        when(result.recreate()).thenReturn(response);\n        MethodDescriptor method = Mockito.mock(MethodDescriptor.class);\n        when(method.getParameterClasses())\n            .thenReturn(new Class[]{String.class});\n        when(method.getMethodName())\n            .thenReturn(\"sayHello\");\n        String request = \"request\";\n        Object ret = StubInvocationUtil.unaryCall(invoker, method, request);\n        Assertions.assertEquals(response, ret);\n    }\n\n    @Test\n    void unaryCall2() throws Throwable {\n        Invoker<DemoService> invoker = Mockito.mock(Invoker.class);\n        URL url = Mockito.mock(URL.class);\n        ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);\n        ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);\n        when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);\n        when(url.getServiceModel())\n            .thenReturn(consumerModel);\n        when(url.getServiceInterface())\n            .thenReturn(DemoService.class.getName());\n        when(url.getProtocolServiceKey())\n            .thenReturn(DemoService.class.getName());\n        when(invoker.getUrl())\n            .thenReturn(url);\n        when(invoker.getInterface())\n            .thenReturn(DemoService.class);\n        Result result = Mockito.mock(Result.class);\n        when(invoker.invoke(any(Invocation.class)))\n            .thenThrow(new RuntimeException(\"a\"))\n            .thenThrow(new Error(\"b\"));\n        String response = \"response\";\n        when(result.recreate()).thenReturn(response);\n        MethodDescriptor method = Mockito.mock(MethodDescriptor.class);\n        when(method.getParameterClasses())\n            .thenReturn(new Class[]{String.class});\n        when(method.getMethodName())\n            .thenReturn(\"sayHello\");\n        String request = \"request\";\n        try {\n            StubInvocationUtil.unaryCall(invoker, method, request);\n            fail();\n        }catch (Throwable t){\n            // pass\n        }\n        try {\n            StubInvocationUtil.unaryCall(invoker, method, request);\n            fail();\n        }catch (Throwable t){\n            // pass\n        }\n    }\n\n    @Test\n    void testUnaryCall() throws Throwable {\n        Invoker<DemoService> invoker = Mockito.mock(Invoker.class);\n        URL url = Mockito.mock(URL.class);\n        ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);\n        ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);\n        when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);\n        when(url.getServiceModel())\n            .thenReturn(consumerModel);\n        when(url.getServiceInterface())\n            .thenReturn(DemoService.class.getName());\n        when(url.getProtocolServiceKey())\n            .thenReturn(DemoService.class.getName());\n        when(invoker.getUrl())\n            .thenReturn(url);\n        when(invoker.getInterface())\n            .thenReturn(DemoService.class);\n        Result result = Mockito.mock(Result.class);\n        String response = \"response\";\n        when(invoker.invoke(any(Invocation.class)))\n            .then(invocationOnMock -> {\n                Invocation invocation = (Invocation) invocationOnMock.getArguments()[0];\n                StreamObserver<Object> observer = (StreamObserver<Object>) invocation.getArguments()[1];\n                observer.onNext(response);\n                observer.onCompleted();\n                return result;\n            });\n        MethodDescriptor method = Mockito.mock(MethodDescriptor.class);\n        when(method.getParameterClasses())\n            .thenReturn(new Class[]{String.class});\n        when(method.getMethodName())\n            .thenReturn(\"sayHello\");\n        String request = \"request\";\n        CountDownLatch latch = new CountDownLatch(1);\n        AtomicReference<Object> atomicReference = new AtomicReference<>();\n        StreamObserver<Object> responseObserver = new StreamObserver<Object>() {\n            @Override\n            public void onNext(Object data) {\n                atomicReference.set(data);\n            }\n\n            @Override\n            public void onError(Throwable throwable) {\n            }\n\n            @Override\n            public void onCompleted() {\n                latch.countDown();\n            }\n        };\n        StubInvocationUtil.unaryCall(invoker, method, request, responseObserver);\n        latch.await(1, TimeUnit.SECONDS);\n        Assertions.assertEquals(response, atomicReference.get());\n    }\n\n    @Test\n    void biOrClientStreamCall() throws InterruptedException {\n        Invoker<DemoService> invoker = Mockito.mock(Invoker.class);\n        URL url = Mockito.mock(URL.class);\n        ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);\n        ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);\n        when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);\n        when(url.getServiceModel())\n            .thenReturn(consumerModel);\n        when(url.getServiceInterface())\n            .thenReturn(DemoService.class.getName());\n        when(url.getProtocolServiceKey())\n            .thenReturn(DemoService.class.getName());\n        when(invoker.getUrl())\n            .thenReturn(url);\n        when(invoker.getInterface())\n            .thenReturn(DemoService.class);\n        Result result = Mockito.mock(Result.class);\n        String response = \"response\";\n\n        when(invoker.invoke(any(Invocation.class)))\n            .then(invocationOnMock -> {\n                Invocation invocation = (Invocation) invocationOnMock.getArguments()[0];\n                StreamObserver<Object> observer = (StreamObserver<Object>) invocation.getArguments()[0];\n                observer.onNext(response);\n                observer.onCompleted();\n                when(result.recreate()).then(invocationOnMock1 -> new StreamObserver<Object>() {\n                    @Override\n                    public void onNext(Object data) {\n                        observer.onNext(data);\n                    }\n\n                    @Override\n                    public void onError(Throwable throwable) {\n\n                    }\n\n                    @Override\n                    public void onCompleted() {\n                        observer.onCompleted();\n                    }\n                });\n                return result;\n            });\n        MethodDescriptor method = Mockito.mock(MethodDescriptor.class);\n        when(method.getParameterClasses())\n            .thenReturn(new Class[]{String.class});\n        when(method.getMethodName())\n            .thenReturn(\"sayHello\");\n        String request = \"request\";\n        CountDownLatch latch = new CountDownLatch(11);\n        StreamObserver<Object> responseObserver = new StreamObserver<Object>() {\n            @Override\n            public void onNext(Object data) {\n                latch.countDown();\n            }\n\n            @Override\n            public void onError(Throwable throwable) {\n            }\n\n            @Override\n            public void onCompleted() {\n                latch.countDown();\n            }\n        };\n        StreamObserver<Object> observer = StubInvocationUtil.biOrClientStreamCall(invoker, method,\n            responseObserver);\n        for (int i = 0; i < 10; i++) {\n            observer.onNext(request);\n        }\n        observer.onCompleted();\n        Assertions.assertTrue(latch.await(1, TimeUnit.SECONDS));\n    }\n\n    @Test\n    void serverStreamCall() throws InterruptedException {\n        Invoker<DemoService> invoker = Mockito.mock(Invoker.class);\n        URL url = Mockito.mock(URL.class);\n        ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);\n        ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);\n        when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);\n        when(url.getServiceModel())\n            .thenReturn(consumerModel);\n        when(url.getServiceInterface())\n            .thenReturn(DemoService.class.getName());\n        when(url.getProtocolServiceKey())\n            .thenReturn(DemoService.class.getName());\n        when(invoker.getUrl())\n            .thenReturn(url);\n        when(invoker.getInterface())\n            .thenReturn(DemoService.class);\n        Result result = Mockito.mock(Result.class);\n        String response = \"response\";\n        when(invoker.invoke(any(Invocation.class)))\n            .then(invocationOnMock -> {\n                Invocation invocation = (Invocation) invocationOnMock.getArguments()[0];\n                StreamObserver<Object> observer = (StreamObserver<Object>) invocation.getArguments()[1];\n                for (int i = 0; i < 10; i++) {\n                    observer.onNext(response);\n                }\n                observer.onCompleted();\n                return result;\n            });\n        MethodDescriptor method = Mockito.mock(MethodDescriptor.class);\n        when(method.getParameterClasses())\n            .thenReturn(new Class[]{String.class});\n        when(method.getMethodName())\n            .thenReturn(\"sayHello\");\n        String request = \"request\";\n        CountDownLatch latch = new CountDownLatch(11);\n        StreamObserver<Object> responseObserver = new StreamObserver<Object>() {\n            @Override\n            public void onNext(Object data) {\n                latch.countDown();\n            }\n\n            @Override\n            public void onError(Throwable throwable) {\n            }\n\n            @Override\n            public void onCompleted() {\n                latch.countDown();\n            }\n        };\n        StubInvocationUtil.serverStreamCall(invoker, method, request, responseObserver);\n        Assertions.assertTrue(latch.await(1, TimeUnit.SECONDS));\n    }\n\n}\n", "newFileContent": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.dubbo.rpc.stub;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.stream.StreamObserver;\nimport org.apache.dubbo.rpc.Invocation;\nimport org.apache.dubbo.rpc.Invoker;\nimport org.apache.dubbo.rpc.Result;\nimport org.apache.dubbo.rpc.model.ConsumerModel;\nimport org.apache.dubbo.rpc.model.MethodDescriptor;\nimport org.apache.dubbo.rpc.model.ServiceDescriptor;\nimport org.apache.dubbo.rpc.support.DemoService;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\n\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport static org.junit.jupiter.api.Assertions.fail;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.when;\n\nclass StubInvocationUtilTest {\n\n    @Test\n    void unaryCall() throws Throwable {\n        Invoker<DemoService> invoker = Mockito.mock(Invoker.class);\n        URL url = Mockito.mock(URL.class);\n        ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);\n        ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);\n        when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);\n        when(url.getServiceModel())\n            .thenReturn(consumerModel);\n        when(url.getServiceInterface())\n            .thenReturn(DemoService.class.getName());\n        when(url.getProtocolServiceKey())\n            .thenReturn(DemoService.class.getName());\n        when(invoker.getUrl())\n            .thenReturn(url);\n        when(invoker.getInterface())\n            .thenReturn(DemoService.class);\n        Result result = Mockito.mock(Result.class);\n        when(invoker.invoke(any(Invocation.class)))\n            .thenReturn(result);\n        String response = \"response\";\n        when(result.recreate()).thenReturn(response);\n        MethodDescriptor method = Mockito.mock(MethodDescriptor.class);\n        when(method.getParameterClasses())\n            .thenReturn(new Class[]{String.class});\n        when(method.getMethodName())\n            .thenReturn(\"sayHello\");\n        String request = \"request\";\n        Object ret = StubInvocationUtil.unaryCall(invoker, method, request);\n        Assertions.assertEquals(response, ret);\n    }\n\n    @Test\n    void unaryCall2() throws Throwable {\n        Invoker<DemoService> invoker = Mockito.mock(Invoker.class);\n        URL url = Mockito.mock(URL.class);\n        ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);\n        ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);\n        when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);\n        when(url.getServiceModel())\n            .thenReturn(consumerModel);\n        when(url.getServiceInterface())\n            .thenReturn(DemoService.class.getName());\n        when(url.getProtocolServiceKey())\n            .thenReturn(DemoService.class.getName());\n        when(invoker.getUrl())\n            .thenReturn(url);\n        when(invoker.getInterface())\n            .thenReturn(DemoService.class);\n        Result result = Mockito.mock(Result.class);\n        when(invoker.invoke(any(Invocation.class)))\n            .thenThrow(new RuntimeException(\"a\"))\n            .thenThrow(new Error(\"b\"));\n        String response = \"response\";\n        when(result.recreate()).thenReturn(response);\n        MethodDescriptor method = Mockito.mock(MethodDescriptor.class);\n        when(method.getParameterClasses())\n            .thenReturn(new Class[]{String.class});\n        when(method.getMethodName())\n            .thenReturn(\"sayHello\");\n        String request = \"request\";\n        try {\n            StubInvocationUtil.unaryCall(invoker, method, request);\n            fail();\n        }catch (Throwable t){\n            // pass\n        }\n        try {\n            StubInvocationUtil.unaryCall(invoker, method, request);\n            fail();\n        }catch (Throwable t){\n            // pass\n        }\n    }\n\n    @Test\n    void testUnaryCall() throws Throwable {\n        Invoker<DemoService> invoker = Mockito.mock(Invoker.class);\n        URL url = Mockito.mock(URL.class);\n        ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);\n        ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);\n        when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);\n        when(url.getServiceModel())\n            .thenReturn(consumerModel);\n        when(url.getServiceInterface())\n            .thenReturn(DemoService.class.getName());\n        when(url.getProtocolServiceKey())\n            .thenReturn(DemoService.class.getName());\n        when(invoker.getUrl())\n            .thenReturn(url);\n        when(invoker.getInterface())\n            .thenReturn(DemoService.class);\n        Result result = Mockito.mock(Result.class);\n        String response = \"response\";\n        when(invoker.invoke(any(Invocation.class)))\n            .then(invocationOnMock -> result);\n        when(result.recreate()).thenReturn(response);\n        MethodDescriptor method = Mockito.mock(MethodDescriptor.class);\n        when(method.getParameterClasses())\n            .thenReturn(new Class[]{String.class});\n        when(method.getMethodName())\n            .thenReturn(\"sayHello\");\n        String request = \"request\";\n        CountDownLatch latch = new CountDownLatch(1);\n        AtomicReference<Object> atomicReference = new AtomicReference<>();\n        StreamObserver<Object> responseObserver = new StreamObserver<Object>() {\n            @Override\n            public void onNext(Object data) {\n                atomicReference.set(data);\n            }\n\n            @Override\n            public void onError(Throwable throwable) {\n            }\n\n            @Override\n            public void onCompleted() {\n                latch.countDown();\n            }\n        };\n        StubInvocationUtil.unaryCall(invoker, method, request, responseObserver);\n        latch.await(1, TimeUnit.SECONDS);\n        Assertions.assertEquals(response, atomicReference.get());\n    }\n\n    @Test\n    void biOrClientStreamCall() throws InterruptedException {\n        Invoker<DemoService> invoker = Mockito.mock(Invoker.class);\n        URL url = Mockito.mock(URL.class);\n        ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);\n        ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);\n        when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);\n        when(url.getServiceModel())\n            .thenReturn(consumerModel);\n        when(url.getServiceInterface())\n            .thenReturn(DemoService.class.getName());\n        when(url.getProtocolServiceKey())\n            .thenReturn(DemoService.class.getName());\n        when(invoker.getUrl())\n            .thenReturn(url);\n        when(invoker.getInterface())\n            .thenReturn(DemoService.class);\n        Result result = Mockito.mock(Result.class);\n        String response = \"response\";\n\n        when(invoker.invoke(any(Invocation.class)))\n            .then(invocationOnMock -> {\n                Invocation invocation = (Invocation) invocationOnMock.getArguments()[0];\n                StreamObserver<Object> observer = (StreamObserver<Object>) invocation.getArguments()[0];\n                observer.onNext(response);\n                observer.onCompleted();\n                when(result.recreate()).then(invocationOnMock1 -> new StreamObserver<Object>() {\n                    @Override\n                    public void onNext(Object data) {\n                        observer.onNext(data);\n                    }\n\n                    @Override\n                    public void onError(Throwable throwable) {\n\n                    }\n\n                    @Override\n                    public void onCompleted() {\n                        observer.onCompleted();\n                    }\n                });\n                return result;\n            });\n        MethodDescriptor method = Mockito.mock(MethodDescriptor.class);\n        when(method.getParameterClasses())\n            .thenReturn(new Class[]{String.class});\n        when(method.getMethodName())\n            .thenReturn(\"sayHello\");\n        String request = \"request\";\n        CountDownLatch latch = new CountDownLatch(11);\n        StreamObserver<Object> responseObserver = new StreamObserver<Object>() {\n            @Override\n            public void onNext(Object data) {\n                latch.countDown();\n            }\n\n            @Override\n            public void onError(Throwable throwable) {\n            }\n\n            @Override\n            public void onCompleted() {\n                latch.countDown();\n            }\n        };\n        StreamObserver<Object> observer = StubInvocationUtil.biOrClientStreamCall(invoker, method,\n            responseObserver);\n        for (int i = 0; i < 10; i++) {\n            observer.onNext(request);\n        }\n        observer.onCompleted();\n        Assertions.assertTrue(latch.await(1, TimeUnit.SECONDS));\n    }\n\n    @Test\n    void serverStreamCall() throws InterruptedException {\n        Invoker<DemoService> invoker = Mockito.mock(Invoker.class);\n        URL url = Mockito.mock(URL.class);\n        ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);\n        ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);\n        when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);\n        when(url.getServiceModel())\n            .thenReturn(consumerModel);\n        when(url.getServiceInterface())\n            .thenReturn(DemoService.class.getName());\n        when(url.getProtocolServiceKey())\n            .thenReturn(DemoService.class.getName());\n        when(invoker.getUrl())\n            .thenReturn(url);\n        when(invoker.getInterface())\n            .thenReturn(DemoService.class);\n        Result result = Mockito.mock(Result.class);\n        String response = \"response\";\n        when(invoker.invoke(any(Invocation.class)))\n            .then(invocationOnMock -> {\n                Invocation invocation = (Invocation) invocationOnMock.getArguments()[0];\n                StreamObserver<Object> observer = (StreamObserver<Object>) invocation.getArguments()[1];\n                for (int i = 0; i < 10; i++) {\n                    observer.onNext(response);\n                }\n                observer.onCompleted();\n                return result;\n            });\n        MethodDescriptor method = Mockito.mock(MethodDescriptor.class);\n        when(method.getParameterClasses())\n            .thenReturn(new Class[]{String.class});\n        when(method.getMethodName())\n            .thenReturn(\"sayHello\");\n        String request = \"request\";\n        CountDownLatch latch = new CountDownLatch(11);\n        StreamObserver<Object> responseObserver = new StreamObserver<Object>() {\n            @Override\n            public void onNext(Object data) {\n                latch.countDown();\n            }\n\n            @Override\n            public void onError(Throwable throwable) {\n            }\n\n            @Override\n            public void onCompleted() {\n                latch.countDown();\n            }\n        };\n        StubInvocationUtil.serverStreamCall(invoker, method, request, responseObserver);\n        Assertions.assertTrue(latch.await(1, TimeUnit.SECONDS));\n    }\n\n}\n", "patch": "@@ -136,13 +136,8 @@ void testUnaryCall() throws Throwable {\n         Result result = Mockito.mock(Result.class);\n         String response = \"response\";\n         when(invoker.invoke(any(Invocation.class)))\n-            .then(invocationOnMock -> {\n-                Invocation invocation = (Invocation) invocationOnMock.getArguments()[0];\n-                StreamObserver<Object> observer = (StreamObserver<Object>) invocation.getArguments()[1];\n-                observer.onNext(response);\n-                observer.onCompleted();\n-                return result;\n-            });\n+            .then(invocationOnMock -> result);\n+        when(result.recreate()).thenReturn(response);\n         MethodDescriptor method = Mockito.mock(MethodDescriptor.class);\n         when(method.getParameterClasses())\n             .thenReturn(new Class[]{String.class});", "description": "\u6587\u4ef6\u884c\u6570\u4fee\u6539\u524d\u4e0d\u7b26\u5408\u89c4\u8303\uff0c\u4fee\u6539\u540e\u7b26\u5408\u89c4\u8303: 304 -> 299 \n"}, {"repository": "apache/dubbo", "commit_sha": "62154c5927621bc24782e30fa28bfa78e84e90b7", "mongoId": "63e2018585d52e6dee1024f8", "fileName": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/ServerCall.java", "oldFileContent": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.dubbo.rpc.protocol.tri.call;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.threadpool.serial.SerializingExecutor;\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.rpc.CancellationContext;\nimport org.apache.dubbo.rpc.Invoker;\nimport org.apache.dubbo.rpc.RpcContext;\nimport org.apache.dubbo.rpc.RpcInvocation;\nimport org.apache.dubbo.rpc.TriRpcStatus;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\nimport org.apache.dubbo.rpc.model.MethodDescriptor;\nimport org.apache.dubbo.rpc.model.PackableMethod;\nimport org.apache.dubbo.rpc.model.ServiceDescriptor;\nimport org.apache.dubbo.rpc.protocol.tri.ClassLoadUtil;\nimport org.apache.dubbo.rpc.protocol.tri.TripleConstant;\nimport org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.Compressor;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.Identity;\nimport org.apache.dubbo.rpc.protocol.tri.observer.ServerCallToObserverAdapter;\nimport org.apache.dubbo.rpc.protocol.tri.stream.ServerStream;\nimport org.apache.dubbo.rpc.protocol.tri.stream.ServerStreamListener;\nimport org.apache.dubbo.rpc.protocol.tri.stream.StreamUtils;\n\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http2.DefaultHttp2Headers;\nimport io.netty.handler.codec.http2.Http2Headers;\n\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\n\nimport static io.netty.handler.codec.http.HttpResponseStatus.OK;\n\npublic abstract class ServerCall {\n\n    public static final String REMOTE_ADDRESS_KEY = \"tri.remote.address\";\n    private static final Logger LOGGER = LoggerFactory.getLogger(ServerCall.class);\n\n    public final Invoker<?> invoker;\n    public final FrameworkModel frameworkModel;\n    public final ServerStream serverStream;\n    public final Executor executor;\n    public final String methodName;\n    public final String serviceName;\n    public final ServiceDescriptor serviceDescriptor;\n    private final String acceptEncoding;\n    public boolean autoRequestN = true;\n    public Long timeout;\n    ServerCall.Listener listener;\n    private Compressor compressor;\n    private boolean headerSent;\n    private boolean closed;\n    protected PackableMethod packableMethod;\n\n\n    ServerCall(Invoker<?> invoker,\n        ServerStream serverStream,\n        FrameworkModel frameworkModel,\n        ServiceDescriptor serviceDescriptor,\n        String acceptEncoding,\n        String serviceName,\n        String methodName,\n        Executor executor) {\n        this.invoker = invoker;\n        this.executor = new SerializingExecutor(executor);\n        this.frameworkModel = frameworkModel;\n        this.serviceDescriptor = serviceDescriptor;\n        this.serviceName = serviceName;\n        this.methodName = methodName;\n        this.serverStream = serverStream;\n        this.acceptEncoding = acceptEncoding;\n    }\n\n    protected abstract ServerStreamListener doStartCall(Map<String, Object> metadata);\n\n    /**\n     * Build the RpcInvocation with metadata and execute headerFilter\n     *\n     * @param headers request header\n     * @return RpcInvocation\n     */\n    protected RpcInvocation buildInvocation(Map<String, Object> headers,\n        MethodDescriptor methodDescriptor) {\n        final URL url = invoker.getUrl();\n        RpcInvocation inv = new RpcInvocation(url.getServiceModel(),\n            methodDescriptor.getMethodName(),\n            serviceDescriptor.getInterfaceName(), url.getProtocolServiceKey(),\n            methodDescriptor.getParameterClasses(),\n            new Object[0]);\n        inv.setTargetServiceUniqueName(url.getServiceKey());\n        inv.setReturnTypes(methodDescriptor.getReturnTypes());\n        inv.setObjectAttachments(StreamUtils.toAttachments(headers));\n        inv.put(REMOTE_ADDRESS_KEY, serverStream.remoteAddress());\n        if (null != headers.get(TripleHeaderEnum.CONSUMER_APP_NAME_KEY.getHeader())) {\n            inv.put(TripleHeaderEnum.CONSUMER_APP_NAME_KEY,\n                headers.get(TripleHeaderEnum.CONSUMER_APP_NAME_KEY.getHeader()));\n        }\n        return inv;\n    }\n\n    public ServerStreamListener startCall(Map<String, Object> metadata) {\n        if (serviceDescriptor == null) {\n            responseErr(\n                TriRpcStatus.UNIMPLEMENTED.withDescription(\"Service not found:\" + serviceName));\n            return null;\n        }\n\n        // handle timeout\n        String timeout = (String) metadata.get(TripleHeaderEnum.TIMEOUT.getHeader());\n        try {\n            if (Objects.nonNull(timeout)) {\n                this.timeout = parseTimeoutToMills(timeout);\n            }\n        } catch (Throwable t) {\n            LOGGER.warn(String.format(\"Failed to parse request timeout set from:%s, service=%s \"\n                + \"method=%s\", timeout, serviceDescriptor.getInterfaceName(), methodName));\n        }\n        return doStartCall(metadata);\n    }\n\n    private void sendHeader() {\n        if (headerSent) {\n            throw new IllegalStateException(\"Header has already sent\");\n        }\n        headerSent = true;\n        DefaultHttp2Headers headers = new DefaultHttp2Headers();\n        headers.status(HttpResponseStatus.OK.codeAsText());\n        headers.set(HttpHeaderNames.CONTENT_TYPE, TripleConstant.CONTENT_PROTO);\n        if (acceptEncoding != null) {\n            headers.set(HttpHeaderNames.ACCEPT_ENCODING, acceptEncoding);\n        }\n        if (compressor != null) {\n            headers.set(TripleHeaderEnum.GRPC_ENCODING.getHeader(),\n                compressor.getMessageEncoding());\n        }\n        serverStream.sendHeader(headers);\n    }\n\n    public void requestN(int n) {\n        serverStream.requestN(n);\n    }\n\n\n    public void setCompression(String compression) {\n        if (headerSent) {\n            throw new IllegalStateException(\"Can not set compression after header sent\");\n        }\n        this.compressor = Compressor.getCompressor(frameworkModel, compression);\n    }\n\n    public void disableAutoRequestN() {\n        autoRequestN = false;\n    }\n\n\n    public boolean isAutoRequestN() {\n        return autoRequestN;\n    }\n\n    public void writeMessage(Object message) {\n        final Runnable writeMessage = () -> doWriteMessage(message);\n        executor.execute(writeMessage);\n    }\n\n    private void doWriteMessage(Object message) {\n        if (closed) {\n            return;\n        }\n        if (!headerSent) {\n            sendHeader();\n        }\n        final byte[] data;\n        try {\n            data = packableMethod.packResponse(message);\n        } catch (IOException e) {\n            close(TriRpcStatus.INTERNAL.withDescription(\"Serialize response failed\")\n                .withCause(e), null);\n            return;\n        }\n        if (data == null) {\n            close(TriRpcStatus.INTERNAL.withDescription(\"Missing response\"), null);\n            return;\n        }\n        if (compressor != null) {\n            int compressedFlag =\n                Identity.MESSAGE_ENCODING.equals(compressor.getMessageEncoding()) ? 0 : 1;\n            final byte[] compressed = compressor.compress(data);\n            serverStream.writeMessage(compressed, compressedFlag);\n        } else {\n            serverStream.writeMessage(data, 0);\n        }\n    }\n\n    public void close(TriRpcStatus status, Map<String, Object> trailers) {\n        executor.execute(() -> serverStream.close(status, trailers));\n    }\n\n    protected Long parseTimeoutToMills(String timeoutVal) {\n        if (StringUtils.isEmpty(timeoutVal) || StringUtils.isContains(timeoutVal, \"null\")) {\n            return null;\n        }\n        long value = Long.parseLong(timeoutVal.substring(0, timeoutVal.length() - 1));\n        char unit = timeoutVal.charAt(timeoutVal.length() - 1);\n        switch (unit) {\n            case 'n':\n                return TimeUnit.NANOSECONDS.toMillis(value);\n            case 'u':\n                return TimeUnit.MICROSECONDS.toMillis(value);\n            case 'm':\n                return value;\n            case 'S':\n                return TimeUnit.SECONDS.toMillis(value);\n            case 'M':\n                return TimeUnit.MINUTES.toMillis(value);\n            case 'H':\n                return TimeUnit.HOURS.toMillis(value);\n            default:\n                // invalid timeout config\n                return null;\n        }\n    }\n\n    /**\n     * Error in create stream, unsupported config or triple protocol error.\n     *\n     * @param status response status\n     */\n    protected void responseErr(TriRpcStatus status) {\n        if (closed) {\n            return;\n        }\n        closed = true;\n        Http2Headers trailers = new DefaultHttp2Headers().status(OK.codeAsText())\n            .set(HttpHeaderNames.CONTENT_TYPE, TripleConstant.CONTENT_PROTO)\n            .setInt(TripleHeaderEnum.STATUS_KEY.getHeader(), status.code.code)\n            .set(TripleHeaderEnum.MESSAGE_KEY.getHeader(), status.toEncodedMessage());\n        serverStream.sendHeaderWithEos(trailers);\n        LOGGER.error(\"Triple request error: service=\" + serviceName + \" method\" + methodName,\n            status.asException());\n    }\n\n    interface Listener {\n\n        void onMessage(Object message);\n\n        void onCancel(String errorInfo);\n\n        void onComplete();\n    }\n\n    abstract class ServerStreamListenerBase implements ServerStreamListener {\n\n        protected boolean closed;\n\n        @Override\n        public void onMessage(byte[] message) {\n            if (closed) {\n                return;\n            }\n            ClassLoader tccl = Thread.currentThread()\n                .getContextClassLoader();\n            try {\n                doOnMessage(message);\n            } catch (Throwable t) {\n                final TriRpcStatus status = TriRpcStatus.INTERNAL.withDescription(\"Server error\")\n                    .withCause(t);\n                close(status, null);\n                LOGGER.error(\n                    \"Process request failed. service=\" + serviceName + \" method=\" + methodName, t);\n            } finally {\n                ClassLoadUtil.switchContextLoader(tccl);\n            }\n        }\n\n        protected abstract void doOnMessage(byte[] message)\n            throws IOException, ClassNotFoundException;\n\n    }\n\n    protected ServerCall.Listener startInternalCall(\n        RpcInvocation invocation,\n        MethodDescriptor methodDescriptor,\n        Invoker<?> invoker) {\n        CancellationContext cancellationContext = RpcContext.getCancellationContext();\n        ServerCallToObserverAdapter<Object> responseObserver =\n            new ServerCallToObserverAdapter<>(this, cancellationContext);\n        try {\n            ServerCall.Listener listener;\n            switch (methodDescriptor.getRpcType()) {\n                case UNARY:\n                    listener = new UnaryServerCallListener(invocation, invoker, responseObserver);\n                    requestN(2);\n                    break;\n                case SERVER_STREAM:\n                    listener = new ServerStreamServerCallListener(invocation, invoker,\n                        responseObserver);\n                    requestN(2);\n                    break;\n                case BI_STREAM:\n                case CLIENT_STREAM:\n                    listener = new BiStreamServerCallListener(invocation, invoker,\n                        responseObserver);\n                    requestN(1);\n                    break;\n                default:\n                    throw new IllegalStateException(\"Can not reach here\");\n            }\n            return listener;\n        } catch (Throwable t) {\n            LOGGER.error(\"Create triple stream failed\", t);\n            responseObserver.onError(TriRpcStatus.INTERNAL.withDescription(\"Create stream failed\")\n                .withCause(t)\n                .asException());\n        }\n        return null;\n    }\n}\n", "newFileContent": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.dubbo.rpc.protocol.tri.call;\n\nimport org.apache.dubbo.rpc.TriRpcStatus;\n\nimport java.util.Map;\n\n/**\n * ServerCall manipulates server details of a RPC call. Request messages are acquired by {@link\n * Listener}. Backpressure is supported by {@link #request(int)}.Response messages are sent by\n * {@link ServerCall#sendMessage(Object)}.\n */\npublic interface ServerCall {\n\n    /**\n     * A listener to receive request messages.\n     */\n    interface Listener {\n\n        /**\n         * Callback when a request message is received.\n         *\n         * @param message message received\n         */\n        void onMessage(Object message);\n\n        /**\n         * @param status when the call is canceled.\n         */\n        void onCancel(TriRpcStatus status);\n\n        /**\n         * Request completed.\n         */\n        void onComplete();\n    }\n\n    /**\n     * Send message to client\n     *\n     * @param message message to send\n     */\n    void sendMessage(Object message);\n\n    /**\n     * Request more request data from the client.\n     *\n     * @param numMessages max number of messages\n     */\n    void request(int numMessages);\n\n    /**\n     * Close the call.\n     *\n     * @param status        status of the call to send to the client\n     * @param responseAttrs response attachments\n     */\n    void close(TriRpcStatus status, Map<String, Object> responseAttrs);\n\n}\n", "patch": "@@ -17,324 +17,60 @@\n \n package org.apache.dubbo.rpc.protocol.tri.call;\n \n-import org.apache.dubbo.common.URL;\n-import org.apache.dubbo.common.logger.Logger;\n-import org.apache.dubbo.common.logger.LoggerFactory;\n-import org.apache.dubbo.common.threadpool.serial.SerializingExecutor;\n-import org.apache.dubbo.common.utils.StringUtils;\n-import org.apache.dubbo.rpc.CancellationContext;\n-import org.apache.dubbo.rpc.Invoker;\n-import org.apache.dubbo.rpc.RpcContext;\n-import org.apache.dubbo.rpc.RpcInvocation;\n import org.apache.dubbo.rpc.TriRpcStatus;\n-import org.apache.dubbo.rpc.model.FrameworkModel;\n-import org.apache.dubbo.rpc.model.MethodDescriptor;\n-import org.apache.dubbo.rpc.model.PackableMethod;\n-import org.apache.dubbo.rpc.model.ServiceDescriptor;\n-import org.apache.dubbo.rpc.protocol.tri.ClassLoadUtil;\n-import org.apache.dubbo.rpc.protocol.tri.TripleConstant;\n-import org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\n-import org.apache.dubbo.rpc.protocol.tri.compressor.Compressor;\n-import org.apache.dubbo.rpc.protocol.tri.compressor.Identity;\n-import org.apache.dubbo.rpc.protocol.tri.observer.ServerCallToObserverAdapter;\n-import org.apache.dubbo.rpc.protocol.tri.stream.ServerStream;\n-import org.apache.dubbo.rpc.protocol.tri.stream.ServerStreamListener;\n-import org.apache.dubbo.rpc.protocol.tri.stream.StreamUtils;\n \n-import io.netty.handler.codec.http.HttpHeaderNames;\n-import io.netty.handler.codec.http.HttpResponseStatus;\n-import io.netty.handler.codec.http2.DefaultHttp2Headers;\n-import io.netty.handler.codec.http2.Http2Headers;\n-\n-import java.io.IOException;\n import java.util.Map;\n-import java.util.Objects;\n-import java.util.concurrent.Executor;\n-import java.util.concurrent.TimeUnit;\n-\n-import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n \n-public abstract class ServerCall {\n+/**\n+ * ServerCall manipulates server details of a RPC call. Request messages are acquired by {@link\n+ * Listener}. Backpressure is supported by {@link #request(int)}.Response messages are sent by\n+ * {@link ServerCall#sendMessage(Object)}.\n+ */\n+public interface ServerCall {\n \n-    public static final String REMOTE_ADDRESS_KEY = \"tri.remote.address\";\n-    private static final Logger LOGGER = LoggerFactory.getLogger(ServerCall.class);\n+    /**\n+     * A listener to receive request messages.\n+     */\n+    interface Listener {\n \n-    public final Invoker<?> invoker;\n-    public final FrameworkModel frameworkModel;\n-    public final ServerStream serverStream;\n-    public final Executor executor;\n-    public final String methodName;\n-    public final String serviceName;\n-    public final ServiceDescriptor serviceDescriptor;\n-    private final String acceptEncoding;\n-    public boolean autoRequestN = true;\n-    public Long timeout;\n-    ServerCall.Listener listener;\n-    private Compressor compressor;\n-    private boolean headerSent;\n-    private boolean closed;\n-    protected PackableMethod packableMethod;\n+        /**\n+         * Callback when a request message is received.\n+         *\n+         * @param message message received\n+         */\n+        void onMessage(Object message);\n \n+        /**\n+         * @param status when the call is canceled.\n+         */\n+        void onCancel(TriRpcStatus status);\n \n-    ServerCall(Invoker<?> invoker,\n-        ServerStream serverStream,\n-        FrameworkModel frameworkModel,\n-        ServiceDescriptor serviceDescriptor,\n-        String acceptEncoding,\n-        String serviceName,\n-        String methodName,\n-        Executor executor) {\n-        this.invoker = invoker;\n-        this.executor = new SerializingExecutor(executor);\n-        this.frameworkModel = frameworkModel;\n-        this.serviceDescriptor = serviceDescriptor;\n-        this.serviceName = serviceName;\n-        this.methodName = methodName;\n-        this.serverStream = serverStream;\n-        this.acceptEncoding = acceptEncoding;\n+        /**\n+         * Request completed.\n+         */\n+        void onComplete();\n     }\n \n-    protected abstract ServerStreamListener doStartCall(Map<String, Object> metadata);\n-\n     /**\n-     * Build the RpcInvocation with metadata and execute headerFilter\n+     * Send message to client\n      *\n-     * @param headers request header\n-     * @return RpcInvocation\n+     * @param message message to send\n      */\n-    protected RpcInvocation buildInvocation(Map<String, Object> headers,\n-        MethodDescriptor methodDescriptor) {\n-        final URL url = invoker.getUrl();\n-        RpcInvocation inv = new RpcInvocation(url.getServiceModel(),\n-            methodDescriptor.getMethodName(),\n-            serviceDescriptor.getInterfaceName(), url.getProtocolServiceKey(),\n-            methodDescriptor.getParameterClasses(),\n-            new Object[0]);\n-        inv.setTargetServiceUniqueName(url.getServiceKey());\n-        inv.setReturnTypes(methodDescriptor.getReturnTypes());\n-        inv.setObjectAttachments(StreamUtils.toAttachments(headers));\n-        inv.put(REMOTE_ADDRESS_KEY, serverStream.remoteAddress());\n-        if (null != headers.get(TripleHeaderEnum.CONSUMER_APP_NAME_KEY.getHeader())) {\n-            inv.put(TripleHeaderEnum.CONSUMER_APP_NAME_KEY,\n-                headers.get(TripleHeaderEnum.CONSUMER_APP_NAME_KEY.getHeader()));\n-        }\n-        return inv;\n-    }\n-\n-    public ServerStreamListener startCall(Map<String, Object> metadata) {\n-        if (serviceDescriptor == null) {\n-            responseErr(\n-                TriRpcStatus.UNIMPLEMENTED.withDescription(\"Service not found:\" + serviceName));\n-            return null;\n-        }\n-\n-        // handle timeout\n-        String timeout = (String) metadata.get(TripleHeaderEnum.TIMEOUT.getHeader());\n-        try {\n-            if (Objects.nonNull(timeout)) {\n-                this.timeout = parseTimeoutToMills(timeout);\n-            }\n-        } catch (Throwable t) {\n-            LOGGER.warn(String.format(\"Failed to parse request timeout set from:%s, service=%s \"\n-                + \"method=%s\", timeout, serviceDescriptor.getInterfaceName(), methodName));\n-        }\n-        return doStartCall(metadata);\n-    }\n-\n-    private void sendHeader() {\n-        if (headerSent) {\n-            throw new IllegalStateException(\"Header has already sent\");\n-        }\n-        headerSent = true;\n-        DefaultHttp2Headers headers = new DefaultHttp2Headers();\n-        headers.status(HttpResponseStatus.OK.codeAsText());\n-        headers.set(HttpHeaderNames.CONTENT_TYPE, TripleConstant.CONTENT_PROTO);\n-        if (acceptEncoding != null) {\n-            headers.set(HttpHeaderNames.ACCEPT_ENCODING, acceptEncoding);\n-        }\n-        if (compressor != null) {\n-            headers.set(TripleHeaderEnum.GRPC_ENCODING.getHeader(),\n-                compressor.getMessageEncoding());\n-        }\n-        serverStream.sendHeader(headers);\n-    }\n-\n-    public void requestN(int n) {\n-        serverStream.requestN(n);\n-    }\n-\n-\n-    public void setCompression(String compression) {\n-        if (headerSent) {\n-            throw new IllegalStateException(\"Can not set compression after header sent\");\n-        }\n-        this.compressor = Compressor.getCompressor(frameworkModel, compression);\n-    }\n-\n-    public void disableAutoRequestN() {\n-        autoRequestN = false;\n-    }\n-\n-\n-    public boolean isAutoRequestN() {\n-        return autoRequestN;\n-    }\n-\n-    public void writeMessage(Object message) {\n-        final Runnable writeMessage = () -> doWriteMessage(message);\n-        executor.execute(writeMessage);\n-    }\n-\n-    private void doWriteMessage(Object message) {\n-        if (closed) {\n-            return;\n-        }\n-        if (!headerSent) {\n-            sendHeader();\n-        }\n-        final byte[] data;\n-        try {\n-            data = packableMethod.packResponse(message);\n-        } catch (IOException e) {\n-            close(TriRpcStatus.INTERNAL.withDescription(\"Serialize response failed\")\n-                .withCause(e), null);\n-            return;\n-        }\n-        if (data == null) {\n-            close(TriRpcStatus.INTERNAL.withDescription(\"Missing response\"), null);\n-            return;\n-        }\n-        if (compressor != null) {\n-            int compressedFlag =\n-                Identity.MESSAGE_ENCODING.equals(compressor.getMessageEncoding()) ? 0 : 1;\n-            final byte[] compressed = compressor.compress(data);\n-            serverStream.writeMessage(compressed, compressedFlag);\n-        } else {\n-            serverStream.writeMessage(data, 0);\n-        }\n-    }\n-\n-    public void close(TriRpcStatus status, Map<String, Object> trailers) {\n-        executor.execute(() -> serverStream.close(status, trailers));\n-    }\n-\n-    protected Long parseTimeoutToMills(String timeoutVal) {\n-        if (StringUtils.isEmpty(timeoutVal) || StringUtils.isContains(timeoutVal, \"null\")) {\n-            return null;\n-        }\n-        long value = Long.parseLong(timeoutVal.substring(0, timeoutVal.length() - 1));\n-        char unit = timeoutVal.charAt(timeoutVal.length() - 1);\n-        switch (unit) {\n-            case 'n':\n-                return TimeUnit.NANOSECONDS.toMillis(value);\n-            case 'u':\n-                return TimeUnit.MICROSECONDS.toMillis(value);\n-            case 'm':\n-                return value;\n-            case 'S':\n-                return TimeUnit.SECONDS.toMillis(value);\n-            case 'M':\n-                return TimeUnit.MINUTES.toMillis(value);\n-            case 'H':\n-                return TimeUnit.HOURS.toMillis(value);\n-            default:\n-                // invalid timeout config\n-                return null;\n-        }\n-    }\n+    void sendMessage(Object message);\n \n     /**\n-     * Error in create stream, unsupported config or triple protocol error.\n+     * Request more request data from the client.\n      *\n-     * @param status response status\n+     * @param numMessages max number of messages\n      */\n-    protected void responseErr(TriRpcStatus status) {\n-        if (closed) {\n-            return;\n-        }\n-        closed = true;\n-        Http2Headers trailers = new DefaultHttp2Headers().status(OK.codeAsText())\n-            .set(HttpHeaderNames.CONTENT_TYPE, TripleConstant.CONTENT_PROTO)\n-            .setInt(TripleHeaderEnum.STATUS_KEY.getHeader(), status.code.code)\n-            .set(TripleHeaderEnum.MESSAGE_KEY.getHeader(), status.toEncodedMessage());\n-        serverStream.sendHeaderWithEos(trailers);\n-        LOGGER.error(\"Triple request error: service=\" + serviceName + \" method\" + methodName,\n-            status.asException());\n-    }\n-\n-    interface Listener {\n-\n-        void onMessage(Object message);\n-\n-        void onCancel(String errorInfo);\n+    void request(int numMessages);\n \n-        void onComplete();\n-    }\n-\n-    abstract class ServerStreamListenerBase implements ServerStreamListener {\n-\n-        protected boolean closed;\n-\n-        @Override\n-        public void onMessage(byte[] message) {\n-            if (closed) {\n-                return;\n-            }\n-            ClassLoader tccl = Thread.currentThread()\n-                .getContextClassLoader();\n-            try {\n-                doOnMessage(message);\n-            } catch (Throwable t) {\n-                final TriRpcStatus status = TriRpcStatus.INTERNAL.withDescription(\"Server error\")\n-                    .withCause(t);\n-                close(status, null);\n-                LOGGER.error(\n-                    \"Process request failed. service=\" + serviceName + \" method=\" + methodName, t);\n-            } finally {\n-                ClassLoadUtil.switchContextLoader(tccl);\n-            }\n-        }\n-\n-        protected abstract void doOnMessage(byte[] message)\n-            throws IOException, ClassNotFoundException;\n-\n-    }\n+    /**\n+     * Close the call.\n+     *\n+     * @param status        status of the call to send to the client\n+     * @param responseAttrs response attachments\n+     */\n+    void close(TriRpcStatus status, Map<String, Object> responseAttrs);\n \n-    protected ServerCall.Listener startInternalCall(\n-        RpcInvocation invocation,\n-        MethodDescriptor methodDescriptor,\n-        Invoker<?> invoker) {\n-        CancellationContext cancellationContext = RpcContext.getCancellationContext();\n-        ServerCallToObserverAdapter<Object> responseObserver =\n-            new ServerCallToObserverAdapter<>(this, cancellationContext);\n-        try {\n-            ServerCall.Listener listener;\n-            switch (methodDescriptor.getRpcType()) {\n-                case UNARY:\n-                    listener = new UnaryServerCallListener(invocation, invoker, responseObserver);\n-                    requestN(2);\n-                    break;\n-                case SERVER_STREAM:\n-                    listener = new ServerStreamServerCallListener(invocation, invoker,\n-                        responseObserver);\n-                    requestN(2);\n-                    break;\n-                case BI_STREAM:\n-                case CLIENT_STREAM:\n-                    listener = new BiStreamServerCallListener(invocation, invoker,\n-                        responseObserver);\n-                    requestN(1);\n-                    break;\n-                default:\n-                    throw new IllegalStateException(\"Can not reach here\");\n-            }\n-            return listener;\n-        } catch (Throwable t) {\n-            LOGGER.error(\"Create triple stream failed\", t);\n-            responseObserver.onError(TriRpcStatus.INTERNAL.withDescription(\"Create stream failed\")\n-                .withCause(t)\n-                .asException());\n-        }\n-        return null;\n-    }\n }", "description": "\u6587\u4ef6\u884c\u6570\u4fee\u6539\u524d\u4e0d\u7b26\u5408\u89c4\u8303\uff0c\u4fee\u6539\u540e\u7b26\u5408\u89c4\u8303: 340 -> 76 \n"}, {"repository": "apache/dubbo", "commit_sha": "62154c5927621bc24782e30fa28bfa78e84e90b7", "mongoId": "63e2018585d52e6dee1024f8", "fileName": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/ClientStream.java", "oldFileContent": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.dubbo.rpc.protocol.tri.stream;\n\nimport org.apache.dubbo.rpc.TriRpcStatus;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\nimport org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\nimport org.apache.dubbo.rpc.protocol.tri.command.CancelQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.DataQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.EndStreamQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.HeaderQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.DeCompressor;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.Identity;\nimport org.apache.dubbo.rpc.protocol.tri.frame.Deframer;\nimport org.apache.dubbo.rpc.protocol.tri.frame.TriDecoder;\nimport org.apache.dubbo.rpc.protocol.tri.transport.AbstractH2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.H2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleCommandOutBoundHandler;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleHttp2ClientResponseHandler;\nimport org.apache.dubbo.rpc.protocol.tri.transport.WriteQueue;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.Channel;\nimport io.netty.handler.codec.http2.Http2Headers;\nimport io.netty.handler.codec.http2.Http2StreamChannel;\nimport io.netty.handler.codec.http2.Http2StreamChannelBootstrap;\nimport io.netty.util.ReferenceCountUtil;\nimport io.netty.util.concurrent.Future;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\nimport java.util.concurrent.Executor;\n\n\n/**\n * ClientStream is an abstraction for bi-directional messaging. It maintains a {@link WriteQueue} to\n * write Http2Frame to remote. A {@link H2TransportListener} receives Http2Frame from remote.\n * Instead of maintaining state, this class depends on upper layer or transport layer's states.\n */\npublic class ClientStream extends AbstractStream implements Stream {\n\n    public final ClientStreamListener listener;\n    private final WriteQueue writeQueue;\n    private Deframer deframer;\n\n    // for test\n    ClientStream(FrameworkModel frameworkModel,\n        Executor executor,\n        WriteQueue writeQueue,\n        ClientStreamListener listener) {\n        super(executor, frameworkModel);\n        this.listener = listener;\n        this.writeQueue = writeQueue;\n    }\n\n    public ClientStream(FrameworkModel frameworkModel,\n        Executor executor,\n        Channel parent,\n        ClientStreamListener listener) {\n        super(executor, frameworkModel);\n        this.listener = listener;\n        this.writeQueue = createWriteQueue(parent);\n    }\n\n    private WriteQueue createWriteQueue(Channel parent) {\n        final Http2StreamChannelBootstrap bootstrap = new Http2StreamChannelBootstrap(parent);\n        final Future<Http2StreamChannel> future = bootstrap.open().syncUninterruptibly();\n        if (!future.isSuccess()) {\n            throw new IllegalStateException(\"Create remote stream failed. channel:\" + parent);\n        }\n        final Http2StreamChannel channel = future.getNow();\n        channel.pipeline()\n            .addLast(new TripleCommandOutBoundHandler())\n            .addLast(new TripleHttp2ClientResponseHandler(createTransportListener()));\n        return new WriteQueue(channel);\n    }\n\n    public void close() {\n        writeQueue.close();\n    }\n\n    public void sendHeader(Http2Headers headers) {\n        if (this.writeQueue == null) {\n            // already processed at createStream()\n            return;\n        }\n        final HeaderQueueCommand headerCmd = HeaderQueueCommand.createHeaders(headers);\n        this.writeQueue.enqueue(headerCmd).addListener(future -> {\n            if (!future.isSuccess()) {\n                transportException(future.cause());\n            }\n        });\n    }\n\n    private void transportException(Throwable cause) {\n        final TriRpcStatus status = TriRpcStatus.INTERNAL.withDescription(\"Http2 exception\")\n            .withCause(cause);\n        listener.complete(status);\n    }\n\n    public void cancelByLocal(TriRpcStatus status) {\n        final CancelQueueCommand cmd = CancelQueueCommand.createCommand();\n        this.writeQueue.enqueue(cmd);\n    }\n\n\n    @Override\n    public void writeMessage(byte[] message, int compressed) {\n        try {\n            final DataQueueCommand cmd = DataQueueCommand.createGrpcCommand(message, false,\n                compressed);\n            this.writeQueue.enqueue(cmd);\n        } catch (Throwable t) {\n            cancelByLocal(\n                TriRpcStatus.INTERNAL.withDescription(\"Client write message failed\").withCause(t));\n        }\n    }\n\n    @Override\n    public void requestN(int n) {\n        deframer.request(n);\n    }\n\n    public void halfClose() {\n        final EndStreamQueueCommand cmd = EndStreamQueueCommand.create();\n        this.writeQueue.enqueue(cmd);\n    }\n\n    /**\n     * @return transport listener\n     */\n    H2TransportListener createTransportListener() {\n        return new ClientTransportListener();\n    }\n\n    class ClientTransportListener extends AbstractH2TransportListener implements\n        H2TransportListener {\n\n        private TriRpcStatus transportError;\n        private DeCompressor decompressor;\n        private boolean remoteClosed;\n        private boolean headerReceived;\n        private Http2Headers trailers;\n\n        void handleH2TransportError(TriRpcStatus status) {\n            writeQueue.enqueue(CancelQueueCommand.createCommand());\n            finishProcess(status, null);\n        }\n\n        void finishProcess(TriRpcStatus status, Http2Headers trailers) {\n            if (remoteClosed) {\n                return;\n            }\n            remoteClosed = true;\n\n            final Map<String, String> reserved = filterReservedHeaders(trailers);\n            final Map<String, Object> attachments = headersToMap(trailers);\n            listener.complete(status, attachments, reserved);\n        }\n\n        private TriRpcStatus validateHeaderStatus(Http2Headers headers) {\n            Integer httpStatus =\n                headers.status() == null ? null : Integer.parseInt(headers.status().toString());\n            if (httpStatus == null) {\n                return TriRpcStatus.INTERNAL.withDescription(\"Missing HTTP status code\");\n            }\n            final CharSequence contentType = headers.get(\n                TripleHeaderEnum.CONTENT_TYPE_KEY.getHeader());\n            if (contentType == null || !contentType.toString()\n                .startsWith(TripleHeaderEnum.APPLICATION_GRPC.getHeader())) {\n                return TriRpcStatus.fromCode(TriRpcStatus.httpStatusToGrpcCode(httpStatus))\n                    .withDescription(\"invalid content-type: \" + contentType);\n            }\n            return null;\n        }\n\n        void onHeaderReceived(Http2Headers headers) {\n            if (transportError != null) {\n                transportError.appendDescription(\"headers:\" + headers);\n                return;\n            }\n            if (headerReceived) {\n                transportError = TriRpcStatus.INTERNAL.withDescription(\"Received headers twice\");\n                return;\n            }\n            Integer httpStatus =\n                headers.status() == null ? null : Integer.parseInt(headers.status().toString());\n\n            if (httpStatus != null && Integer.parseInt(httpStatus.toString()) > 100\n                && httpStatus < 200) {\n                // ignored\n                return;\n            }\n            headerReceived = true;\n            transportError = validateHeaderStatus(headers);\n\n            // todo support full payload compressor\n            CharSequence messageEncoding = headers.get(TripleHeaderEnum.GRPC_ENCODING.getHeader());\n            if (null != messageEncoding) {\n                String compressorStr = messageEncoding.toString();\n                if (!Identity.IDENTITY.getMessageEncoding().equals(compressorStr)) {\n                    DeCompressor compressor = DeCompressor.getCompressor(frameworkModel,\n                        compressorStr);\n                    if (null == compressor) {\n                        throw TriRpcStatus.UNIMPLEMENTED.withDescription(String.format(\n                            \"Grpc-encoding '%s' is not supported\",\n                            compressorStr)).asException();\n                    } else {\n                        decompressor = compressor;\n                    }\n                }\n            }\n            TriDecoder.Listener listener = new TriDecoder.Listener() {\n                @Override\n                public void onRawMessage(byte[] data) {\n                    ClientStream.this.listener.onMessage(data);\n                }\n\n                public void close() {\n                    finishProcess(statusFromTrailers(trailers), trailers);\n                }\n            };\n            deframer = new TriDecoder(decompressor, listener);\n            ClientStream.this.listener.onStart();\n        }\n\n        void onTrailersReceived(Http2Headers trailers) {\n            if (transportError == null && !headerReceived) {\n                transportError = validateHeaderStatus(trailers);\n            }\n            if (transportError != null) {\n                transportError = transportError.appendDescription(\"trailers: \" + trailers);\n            } else {\n                this.trailers = trailers;\n                TriRpcStatus status = statusFromTrailers(trailers);\n                if (deframer == null) {\n                    finishProcess(status, trailers);\n                }\n                if (deframer != null) {\n                    deframer.close();\n                }\n            }\n        }\n\n        /**\n         * Extract the response status from trailers.\n         */\n        private TriRpcStatus statusFromTrailers(Http2Headers trailers) {\n            final Integer intStatus = trailers.getInt(TripleHeaderEnum.STATUS_KEY.getHeader());\n            TriRpcStatus status = intStatus == null ? null : TriRpcStatus.fromCode(intStatus);\n            if (status != null) {\n                final CharSequence message = trailers.get(TripleHeaderEnum.MESSAGE_KEY.getHeader());\n                if (message != null) {\n                    final String description = TriRpcStatus.decodeMessage(message.toString());\n                    status = status.withDescription(description);\n                }\n                return status;\n            }\n            // No status; something is broken. Try to provide a rational error.\n            if (headerReceived) {\n                return TriRpcStatus.UNKNOWN.withDescription(\"missing GRPC status in response\");\n            }\n            Integer httpStatus =\n                trailers.status() == null ? null : Integer.parseInt(trailers.status().toString());\n            if (httpStatus != null) {\n                status = TriRpcStatus.fromCode(TriRpcStatus.httpStatusToGrpcCode(httpStatus));\n            } else {\n                status = TriRpcStatus.INTERNAL.withDescription(\"missing HTTP status code\");\n            }\n            return status.appendDescription(\n                \"missing GRPC status, inferred error from HTTP status code\");\n        }\n\n        @Override\n        public void onHeader(Http2Headers headers, boolean endStream) {\n            executor.execute(() -> {\n                if (endStream) {\n                    if (!remoteClosed) {\n                        writeQueue.enqueue(CancelQueueCommand.createCommand());\n                    }\n                    onTrailersReceived(headers);\n                } else {\n                    onHeaderReceived(headers);\n                }\n            });\n\n        }\n\n        @Override\n        public void onData(ByteBuf data, boolean endStream) {\n            executor.execute(() -> {\n                if (transportError != null) {\n                    transportError.appendDescription(\n                        \"Data:\" + data.toString(StandardCharsets.UTF_8));\n                    ReferenceCountUtil.release(data);\n                    if (transportError.description.length() > 512 || endStream) {\n                        handleH2TransportError(transportError);\n\n                    }\n                    return;\n                }\n                if (!headerReceived) {\n                    handleH2TransportError(TriRpcStatus.INTERNAL.withDescription(\n                        \"headers not received before payload\"));\n                    return;\n                }\n                deframer.deframe(data);\n            });\n        }\n\n        @Override\n        public void cancelByRemote(TriRpcStatus status) {\n            executor.execute(() -> {\n                transportError = status;\n                finishProcess(status, null);\n            });\n        }\n    }\n}\n", "newFileContent": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.dubbo.rpc.protocol.tri.stream;\n\nimport org.apache.dubbo.rpc.TriRpcStatus;\n\nimport io.netty.util.concurrent.Future;\n\nimport java.util.Map;\n\n/**\n * ClientStream is used to send request to server and receive response from server. Response is\n * received by {@link ClientStream.Listener} Requests are sent by {@link ClientStream} directly.\n */\npublic interface ClientStream extends Stream {\n\n    interface Listener extends Stream.Listener {\n\n        /**\n         * Callback when stream started.\n         */\n        void onStart();\n\n        /**\n         * Callback when stream completed.\n         *\n         * @param attachments received from remote peer\n         */\n        default void onComplete(TriRpcStatus status, Map<String, Object> attachments) {\n        }\n\n        /**\n         * Callback when request completed.\n         *\n         * @param status      response status\n         * @param attachments attachments received from remote peer\n         * @param reserved    triple protocol reserved data\n         */\n        default void onComplete(TriRpcStatus status, Map<String, Object> attachments,\n            Map<String, String> reserved) {\n            onComplete(status, attachments);\n        }\n\n    }\n\n    /**\n     * Send message to remote peer.\n     *\n     * @param message message to send to remote peer\n     * @param eos     whether this is the last message\n     * @return future to callback when send message is done\n     */\n    Future<?> sendMessage(byte[] message, int compressFlag, boolean eos);\n\n    /**\n     * No more data will be sent, half close this stream to wait server response.\n     *\n     * @return a future of send result\n     */\n    Future<?> halfClose();\n\n}\n", "patch": "@@ -18,317 +18,60 @@\n package org.apache.dubbo.rpc.protocol.tri.stream;\n \n import org.apache.dubbo.rpc.TriRpcStatus;\n-import org.apache.dubbo.rpc.model.FrameworkModel;\n-import org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\n-import org.apache.dubbo.rpc.protocol.tri.command.CancelQueueCommand;\n-import org.apache.dubbo.rpc.protocol.tri.command.DataQueueCommand;\n-import org.apache.dubbo.rpc.protocol.tri.command.EndStreamQueueCommand;\n-import org.apache.dubbo.rpc.protocol.tri.command.HeaderQueueCommand;\n-import org.apache.dubbo.rpc.protocol.tri.compressor.DeCompressor;\n-import org.apache.dubbo.rpc.protocol.tri.compressor.Identity;\n-import org.apache.dubbo.rpc.protocol.tri.frame.Deframer;\n-import org.apache.dubbo.rpc.protocol.tri.frame.TriDecoder;\n-import org.apache.dubbo.rpc.protocol.tri.transport.AbstractH2TransportListener;\n-import org.apache.dubbo.rpc.protocol.tri.transport.H2TransportListener;\n-import org.apache.dubbo.rpc.protocol.tri.transport.TripleCommandOutBoundHandler;\n-import org.apache.dubbo.rpc.protocol.tri.transport.TripleHttp2ClientResponseHandler;\n-import org.apache.dubbo.rpc.protocol.tri.transport.WriteQueue;\n \n-import io.netty.buffer.ByteBuf;\n-import io.netty.channel.Channel;\n-import io.netty.handler.codec.http2.Http2Headers;\n-import io.netty.handler.codec.http2.Http2StreamChannel;\n-import io.netty.handler.codec.http2.Http2StreamChannelBootstrap;\n-import io.netty.util.ReferenceCountUtil;\n import io.netty.util.concurrent.Future;\n \n-import java.nio.charset.StandardCharsets;\n import java.util.Map;\n-import java.util.concurrent.Executor;\n-\n \n /**\n- * ClientStream is an abstraction for bi-directional messaging. It maintains a {@link WriteQueue} to\n- * write Http2Frame to remote. A {@link H2TransportListener} receives Http2Frame from remote.\n- * Instead of maintaining state, this class depends on upper layer or transport layer's states.\n+ * ClientStream is used to send request to server and receive response from server. Response is\n+ * received by {@link ClientStream.Listener} Requests are sent by {@link ClientStream} directly.\n  */\n-public class ClientStream extends AbstractStream implements Stream {\n-\n-    public final ClientStreamListener listener;\n-    private final WriteQueue writeQueue;\n-    private Deframer deframer;\n-\n-    // for test\n-    ClientStream(FrameworkModel frameworkModel,\n-        Executor executor,\n-        WriteQueue writeQueue,\n-        ClientStreamListener listener) {\n-        super(executor, frameworkModel);\n-        this.listener = listener;\n-        this.writeQueue = writeQueue;\n-    }\n+public interface ClientStream extends Stream {\n \n-    public ClientStream(FrameworkModel frameworkModel,\n-        Executor executor,\n-        Channel parent,\n-        ClientStreamListener listener) {\n-        super(executor, frameworkModel);\n-        this.listener = listener;\n-        this.writeQueue = createWriteQueue(parent);\n-    }\n-\n-    private WriteQueue createWriteQueue(Channel parent) {\n-        final Http2StreamChannelBootstrap bootstrap = new Http2StreamChannelBootstrap(parent);\n-        final Future<Http2StreamChannel> future = bootstrap.open().syncUninterruptibly();\n-        if (!future.isSuccess()) {\n-            throw new IllegalStateException(\"Create remote stream failed. channel:\" + parent);\n-        }\n-        final Http2StreamChannel channel = future.getNow();\n-        channel.pipeline()\n-            .addLast(new TripleCommandOutBoundHandler())\n-            .addLast(new TripleHttp2ClientResponseHandler(createTransportListener()));\n-        return new WriteQueue(channel);\n-    }\n+    interface Listener extends Stream.Listener {\n \n-    public void close() {\n-        writeQueue.close();\n-    }\n+        /**\n+         * Callback when stream started.\n+         */\n+        void onStart();\n \n-    public void sendHeader(Http2Headers headers) {\n-        if (this.writeQueue == null) {\n-            // already processed at createStream()\n-            return;\n+        /**\n+         * Callback when stream completed.\n+         *\n+         * @param attachments received from remote peer\n+         */\n+        default void onComplete(TriRpcStatus status, Map<String, Object> attachments) {\n         }\n-        final HeaderQueueCommand headerCmd = HeaderQueueCommand.createHeaders(headers);\n-        this.writeQueue.enqueue(headerCmd).addListener(future -> {\n-            if (!future.isSuccess()) {\n-                transportException(future.cause());\n-            }\n-        });\n-    }\n \n-    private void transportException(Throwable cause) {\n-        final TriRpcStatus status = TriRpcStatus.INTERNAL.withDescription(\"Http2 exception\")\n-            .withCause(cause);\n-        listener.complete(status);\n-    }\n-\n-    public void cancelByLocal(TriRpcStatus status) {\n-        final CancelQueueCommand cmd = CancelQueueCommand.createCommand();\n-        this.writeQueue.enqueue(cmd);\n-    }\n-\n-\n-    @Override\n-    public void writeMessage(byte[] message, int compressed) {\n-        try {\n-            final DataQueueCommand cmd = DataQueueCommand.createGrpcCommand(message, false,\n-                compressed);\n-            this.writeQueue.enqueue(cmd);\n-        } catch (Throwable t) {\n-            cancelByLocal(\n-                TriRpcStatus.INTERNAL.withDescription(\"Client write message failed\").withCause(t));\n+        /**\n+         * Callback when request completed.\n+         *\n+         * @param status      response status\n+         * @param attachments attachments received from remote peer\n+         * @param reserved    triple protocol reserved data\n+         */\n+        default void onComplete(TriRpcStatus status, Map<String, Object> attachments,\n+            Map<String, String> reserved) {\n+            onComplete(status, attachments);\n         }\n-    }\n-\n-    @Override\n-    public void requestN(int n) {\n-        deframer.request(n);\n-    }\n \n-    public void halfClose() {\n-        final EndStreamQueueCommand cmd = EndStreamQueueCommand.create();\n-        this.writeQueue.enqueue(cmd);\n     }\n \n     /**\n-     * @return transport listener\n+     * Send message to remote peer.\n+     *\n+     * @param message message to send to remote peer\n+     * @param eos     whether this is the last message\n+     * @return future to callback when send message is done\n      */\n-    H2TransportListener createTransportListener() {\n-        return new ClientTransportListener();\n-    }\n-\n-    class ClientTransportListener extends AbstractH2TransportListener implements\n-        H2TransportListener {\n-\n-        private TriRpcStatus transportError;\n-        private DeCompressor decompressor;\n-        private boolean remoteClosed;\n-        private boolean headerReceived;\n-        private Http2Headers trailers;\n+    Future<?> sendMessage(byte[] message, int compressFlag, boolean eos);\n \n-        void handleH2TransportError(TriRpcStatus status) {\n-            writeQueue.enqueue(CancelQueueCommand.createCommand());\n-            finishProcess(status, null);\n-        }\n-\n-        void finishProcess(TriRpcStatus status, Http2Headers trailers) {\n-            if (remoteClosed) {\n-                return;\n-            }\n-            remoteClosed = true;\n-\n-            final Map<String, String> reserved = filterReservedHeaders(trailers);\n-            final Map<String, Object> attachments = headersToMap(trailers);\n-            listener.complete(status, attachments, reserved);\n-        }\n-\n-        private TriRpcStatus validateHeaderStatus(Http2Headers headers) {\n-            Integer httpStatus =\n-                headers.status() == null ? null : Integer.parseInt(headers.status().toString());\n-            if (httpStatus == null) {\n-                return TriRpcStatus.INTERNAL.withDescription(\"Missing HTTP status code\");\n-            }\n-            final CharSequence contentType = headers.get(\n-                TripleHeaderEnum.CONTENT_TYPE_KEY.getHeader());\n-            if (contentType == null || !contentType.toString()\n-                .startsWith(TripleHeaderEnum.APPLICATION_GRPC.getHeader())) {\n-                return TriRpcStatus.fromCode(TriRpcStatus.httpStatusToGrpcCode(httpStatus))\n-                    .withDescription(\"invalid content-type: \" + contentType);\n-            }\n-            return null;\n-        }\n-\n-        void onHeaderReceived(Http2Headers headers) {\n-            if (transportError != null) {\n-                transportError.appendDescription(\"headers:\" + headers);\n-                return;\n-            }\n-            if (headerReceived) {\n-                transportError = TriRpcStatus.INTERNAL.withDescription(\"Received headers twice\");\n-                return;\n-            }\n-            Integer httpStatus =\n-                headers.status() == null ? null : Integer.parseInt(headers.status().toString());\n-\n-            if (httpStatus != null && Integer.parseInt(httpStatus.toString()) > 100\n-                && httpStatus < 200) {\n-                // ignored\n-                return;\n-            }\n-            headerReceived = true;\n-            transportError = validateHeaderStatus(headers);\n-\n-            // todo support full payload compressor\n-            CharSequence messageEncoding = headers.get(TripleHeaderEnum.GRPC_ENCODING.getHeader());\n-            if (null != messageEncoding) {\n-                String compressorStr = messageEncoding.toString();\n-                if (!Identity.IDENTITY.getMessageEncoding().equals(compressorStr)) {\n-                    DeCompressor compressor = DeCompressor.getCompressor(frameworkModel,\n-                        compressorStr);\n-                    if (null == compressor) {\n-                        throw TriRpcStatus.UNIMPLEMENTED.withDescription(String.format(\n-                            \"Grpc-encoding '%s' is not supported\",\n-                            compressorStr)).asException();\n-                    } else {\n-                        decompressor = compressor;\n-                    }\n-                }\n-            }\n-            TriDecoder.Listener listener = new TriDecoder.Listener() {\n-                @Override\n-                public void onRawMessage(byte[] data) {\n-                    ClientStream.this.listener.onMessage(data);\n-                }\n-\n-                public void close() {\n-                    finishProcess(statusFromTrailers(trailers), trailers);\n-                }\n-            };\n-            deframer = new TriDecoder(decompressor, listener);\n-            ClientStream.this.listener.onStart();\n-        }\n-\n-        void onTrailersReceived(Http2Headers trailers) {\n-            if (transportError == null && !headerReceived) {\n-                transportError = validateHeaderStatus(trailers);\n-            }\n-            if (transportError != null) {\n-                transportError = transportError.appendDescription(\"trailers: \" + trailers);\n-            } else {\n-                this.trailers = trailers;\n-                TriRpcStatus status = statusFromTrailers(trailers);\n-                if (deframer == null) {\n-                    finishProcess(status, trailers);\n-                }\n-                if (deframer != null) {\n-                    deframer.close();\n-                }\n-            }\n-        }\n-\n-        /**\n-         * Extract the response status from trailers.\n-         */\n-        private TriRpcStatus statusFromTrailers(Http2Headers trailers) {\n-            final Integer intStatus = trailers.getInt(TripleHeaderEnum.STATUS_KEY.getHeader());\n-            TriRpcStatus status = intStatus == null ? null : TriRpcStatus.fromCode(intStatus);\n-            if (status != null) {\n-                final CharSequence message = trailers.get(TripleHeaderEnum.MESSAGE_KEY.getHeader());\n-                if (message != null) {\n-                    final String description = TriRpcStatus.decodeMessage(message.toString());\n-                    status = status.withDescription(description);\n-                }\n-                return status;\n-            }\n-            // No status; something is broken. Try to provide a rational error.\n-            if (headerReceived) {\n-                return TriRpcStatus.UNKNOWN.withDescription(\"missing GRPC status in response\");\n-            }\n-            Integer httpStatus =\n-                trailers.status() == null ? null : Integer.parseInt(trailers.status().toString());\n-            if (httpStatus != null) {\n-                status = TriRpcStatus.fromCode(TriRpcStatus.httpStatusToGrpcCode(httpStatus));\n-            } else {\n-                status = TriRpcStatus.INTERNAL.withDescription(\"missing HTTP status code\");\n-            }\n-            return status.appendDescription(\n-                \"missing GRPC status, inferred error from HTTP status code\");\n-        }\n-\n-        @Override\n-        public void onHeader(Http2Headers headers, boolean endStream) {\n-            executor.execute(() -> {\n-                if (endStream) {\n-                    if (!remoteClosed) {\n-                        writeQueue.enqueue(CancelQueueCommand.createCommand());\n-                    }\n-                    onTrailersReceived(headers);\n-                } else {\n-                    onHeaderReceived(headers);\n-                }\n-            });\n-\n-        }\n-\n-        @Override\n-        public void onData(ByteBuf data, boolean endStream) {\n-            executor.execute(() -> {\n-                if (transportError != null) {\n-                    transportError.appendDescription(\n-                        \"Data:\" + data.toString(StandardCharsets.UTF_8));\n-                    ReferenceCountUtil.release(data);\n-                    if (transportError.description.length() > 512 || endStream) {\n-                        handleH2TransportError(transportError);\n-\n-                    }\n-                    return;\n-                }\n-                if (!headerReceived) {\n-                    handleH2TransportError(TriRpcStatus.INTERNAL.withDescription(\n-                        \"headers not received before payload\"));\n-                    return;\n-                }\n-                deframer.deframe(data);\n-            });\n-        }\n+    /**\n+     * No more data will be sent, half close this stream to wait server response.\n+     *\n+     * @return a future of send result\n+     */\n+    Future<?> halfClose();\n \n-        @Override\n-        public void cancelByRemote(TriRpcStatus status) {\n-            executor.execute(() -> {\n-                transportError = status;\n-                finishProcess(status, null);\n-            });\n-        }\n-    }\n }", "description": "\u6587\u4ef6\u884c\u6570\u4fee\u6539\u524d\u4e0d\u7b26\u5408\u89c4\u8303\uff0c\u4fee\u6539\u540e\u7b26\u5408\u89c4\u8303: 334 -> 77 \n"}, {"repository": "apache/dubbo", "commit_sha": "62154c5927621bc24782e30fa28bfa78e84e90b7", "mongoId": "63e2018585d52e6dee1024f8", "fileName": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/ServerStream.java", "oldFileContent": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.dubbo.rpc.protocol.tri.stream;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.rpc.HeaderFilter;\nimport org.apache.dubbo.rpc.Invoker;\nimport org.apache.dubbo.rpc.PathResolver;\nimport org.apache.dubbo.rpc.TriRpcStatus;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\nimport org.apache.dubbo.rpc.protocol.tri.ExceptionUtils;\nimport org.apache.dubbo.rpc.protocol.tri.TripleConstant;\nimport org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\nimport org.apache.dubbo.rpc.protocol.tri.call.ReflectionServerCall;\nimport org.apache.dubbo.rpc.protocol.tri.call.ServerCall;\nimport org.apache.dubbo.rpc.protocol.tri.call.StubServerCall;\nimport org.apache.dubbo.rpc.protocol.tri.command.DataQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.HeaderQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.TextDataQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.DeCompressor;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.Identity;\nimport org.apache.dubbo.rpc.protocol.tri.frame.Deframer;\nimport org.apache.dubbo.rpc.protocol.tri.frame.TriDecoder;\nimport org.apache.dubbo.rpc.protocol.tri.transport.AbstractH2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.H2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.WriteQueue;\n\nimport com.google.protobuf.Any;\nimport com.google.rpc.DebugInfo;\nimport com.google.rpc.Status;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.Channel;\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpMethod;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http.HttpUtil;\nimport io.netty.handler.codec.http2.DefaultHttp2Headers;\nimport io.netty.handler.codec.http2.Http2Headers;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.GenericFutureListener;\n\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.concurrent.Executor;\n\nimport static io.netty.handler.codec.http.HttpResponseStatus.OK;\n\npublic class ServerStream extends AbstractStream {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(ServerStream.class);\n    public final ServerTransportObserver transportObserver = new ServerTransportObserver();\n    private final WriteQueue writeQueue;\n    private final PathResolver pathResolver;\n    private final List<HeaderFilter> filters;\n    private final String acceptEncoding;\n    private boolean headerSent;\n    private boolean trailersSent;\n    private ServerStreamListener listener;\n    private boolean closed;\n    private final InetSocketAddress remoteAddress;\n    private Deframer deframer;\n\n    public ServerStream(Channel channel,\n        FrameworkModel frameworkModel,\n        Executor executor,\n        PathResolver pathResolver,\n        String acceptEncoding,\n        List<HeaderFilter> filters) {\n        super(executor, frameworkModel);\n        this.pathResolver = pathResolver;\n        this.acceptEncoding = acceptEncoding;\n        this.filters = filters;\n        this.writeQueue = new WriteQueue(channel);\n        this.remoteAddress = (InetSocketAddress) channel.remoteAddress();\n    }\n\n    public SocketAddress remoteAddress() {\n        return remoteAddress;\n    }\n\n    private String getGrpcMessage(TriRpcStatus status) {\n        if (StringUtils.isNotEmpty(status.description)) {\n            return status.description;\n        }\n        return Optional.ofNullable(status.cause).map(Throwable::getMessage).orElse(\"unknown\");\n    }\n\n    public void sendHeader(Http2Headers headers) {\n        if (headerSent && trailersSent) {\n            // todo handle this state\n            return;\n        }\n        GenericFutureListener<Future<? super Void>> listener = future -> {\n            if (future.isSuccess()) {\n                return;\n            }\n            LOGGER.warn(\"Send response header failed:\" + headers, future.cause());\n        };\n        if (headerSent) {\n            trailersSent = true;\n            writeQueue.enqueue(HeaderQueueCommand.createHeaders(headers, true))\n                .addListener(listener);\n        } else {\n            headerSent = true;\n            writeQueue.enqueue(HeaderQueueCommand.createHeaders(headers, false))\n                .addListener(listener);\n        }\n    }\n\n    public void sendHeaderWithEos(Http2Headers headers) {\n        headerSent = true;\n        sendHeader(headers);\n    }\n\n    public void close(TriRpcStatus status, Map<String, Object> attachments) {\n        if (closed) {\n            return;\n        }\n        closed = true;\n        final Http2Headers headers = getTrailers(status, attachments);\n        sendHeaderWithEos(headers);\n    }\n\n    private Http2Headers getTrailers(TriRpcStatus rpcStatus, Map<String, Object> attachments) {\n        DefaultHttp2Headers headers = new DefaultHttp2Headers();\n        if (!headerSent) {\n            headers.status(HttpResponseStatus.OK.codeAsText());\n            headers.set(HttpHeaderNames.CONTENT_TYPE, TripleConstant.CONTENT_PROTO);\n        }\n        StreamUtils.convertAttachment(headers, attachments);\n        headers.set(TripleHeaderEnum.STATUS_KEY.getHeader(), String.valueOf(rpcStatus.code.code));\n        if (rpcStatus.isOk()) {\n            return headers;\n        }\n        String grpcMessage = getGrpcMessage(rpcStatus);\n        grpcMessage = TriRpcStatus.encodeMessage(TriRpcStatus.limitSizeTo1KB(grpcMessage));\n        headers.set(TripleHeaderEnum.MESSAGE_KEY.getHeader(), grpcMessage);\n        Status.Builder builder = Status.newBuilder().setCode(rpcStatus.code.code)\n            .setMessage(grpcMessage);\n        Throwable throwable = rpcStatus.cause;\n        if (throwable == null) {\n            Status status = builder.build();\n            headers.set(TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader(),\n                StreamUtils.encodeBase64ASCII(status.toByteArray()));\n            return headers;\n        }\n        DebugInfo debugInfo = DebugInfo.newBuilder()\n            .addAllStackEntries(ExceptionUtils.getStackFrameList(throwable, 6))\n            // can not use now\n            // .setDetail(throwable.getMessage())\n            .build();\n        builder.addDetails(Any.pack(debugInfo));\n        Status status = builder.build();\n        headers.set(TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader(),\n            StreamUtils.encodeBase64ASCII(status.toByteArray()));\n        return headers;\n    }\n\n    @Override\n    public void writeMessage(byte[] message, int compressed) {\n        writeQueue.enqueue(DataQueueCommand.createGrpcCommand(message, false, compressed));\n    }\n\n    @Override\n    public void requestN(int n) {\n        deframer.request(n);\n    }\n\n    /**\n     * Error before create server stream, http plain text will be returned\n     *\n     * @param code\n     * @param status\n     */\n    private void responsePlainTextError(int code, TriRpcStatus status) {\n        Http2Headers headers = new DefaultHttp2Headers(true).status(String.valueOf(code))\n            .setInt(TripleHeaderEnum.STATUS_KEY.getHeader(), status.code.code)\n            .set(TripleHeaderEnum.MESSAGE_KEY.getHeader(), status.description)\n            .set(TripleHeaderEnum.CONTENT_TYPE_KEY.getHeader(), TripleConstant.TEXT_PLAIN_UTF8);\n        writeQueue.enqueue(HeaderQueueCommand.createHeaders(headers, false));\n        writeQueue.enqueue(TextDataQueueCommand.createCommand(status.description, true));\n    }\n\n    /**\n     * Error in create stream, unsupported config or triple protocol error.\n     *\n     * @param status\n     */\n    private void responseErr(TriRpcStatus status) {\n        Http2Headers trailers = new DefaultHttp2Headers().status(OK.codeAsText())\n            .set(HttpHeaderNames.CONTENT_TYPE, TripleConstant.CONTENT_PROTO)\n            .setInt(TripleHeaderEnum.STATUS_KEY.getHeader(), status.code.code)\n            .set(TripleHeaderEnum.MESSAGE_KEY.getHeader(), status.toEncodedMessage());\n        writeQueue.enqueue(HeaderQueueCommand.createHeaders(trailers, true));\n    }\n\n\n    private Invoker<?> getInvoker(Http2Headers headers, String serviceName) {\n        final String version =\n            headers.contains(TripleHeaderEnum.SERVICE_VERSION.getHeader()) ? headers.get(\n                TripleHeaderEnum.SERVICE_VERSION.getHeader()).toString() : null;\n        final String group =\n            headers.contains(TripleHeaderEnum.SERVICE_GROUP.getHeader()) ? headers.get(\n                TripleHeaderEnum.SERVICE_GROUP.getHeader()).toString() : null;\n        final String key = URL.buildKey(serviceName, group, version);\n        Invoker<?> invoker = pathResolver.resolve(key);\n        if (invoker == null) {\n            invoker = pathResolver.resolve(URL.buildKey(serviceName, group, \"1.0.0\"));\n        }\n        if (invoker == null) {\n            invoker = pathResolver.resolve(serviceName);\n        }\n        return invoker;\n    }\n\n    public class ServerTransportObserver extends AbstractH2TransportListener implements\n        H2TransportListener {\n\n        /**\n         * must starts from application/grpc\n         */\n        private boolean supportContentType(String contentType) {\n            if (contentType == null) {\n                return false;\n            }\n            return contentType.startsWith(TripleConstant.APPLICATION_GRPC);\n        }\n\n        @Override\n        public void onHeader(Http2Headers headers, boolean endStream) {\n            executor.execute(() -> processHeader(headers, endStream));\n        }\n\n        private void processHeader(Http2Headers headers, boolean endStream) {\n            if (!HttpMethod.POST.asciiName().contentEquals(headers.method())) {\n                responsePlainTextError(HttpResponseStatus.METHOD_NOT_ALLOWED.code(),\n                    TriRpcStatus.INTERNAL.withDescription(\n                        String.format(\"Method '%s' is not supported\", headers.method())));\n                return;\n            }\n\n            if (headers.path() == null) {\n                responsePlainTextError(HttpResponseStatus.NOT_FOUND.code(),\n                    TriRpcStatus.fromCode(TriRpcStatus.Code.UNIMPLEMENTED.code)\n                        .withDescription(\"Expected path but is missing\"));\n                return;\n            }\n\n            final String path = headers.path().toString();\n            if (path.charAt(0) != '/') {\n                responsePlainTextError(HttpResponseStatus.NOT_FOUND.code(),\n                    TriRpcStatus.fromCode(TriRpcStatus.Code.UNIMPLEMENTED.code)\n                        .withDescription(String.format(\"Expected path to start with /: %s\", path)));\n                return;\n            }\n\n            final CharSequence contentType = HttpUtil.getMimeType(\n                headers.get(HttpHeaderNames.CONTENT_TYPE));\n            if (contentType == null) {\n                responsePlainTextError(HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE.code(),\n                    TriRpcStatus.fromCode(TriRpcStatus.Code.INTERNAL.code)\n                        .withDescription(\"Content-Type is missing from the request\"));\n                return;\n            }\n\n            final String contentString = contentType.toString();\n            if (!supportContentType(contentString)) {\n                responsePlainTextError(HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE.code(),\n                    TriRpcStatus.fromCode(TriRpcStatus.Code.INTERNAL.code)\n                        .withDescription(\n                            String.format(\"Content-Type '%s' is not supported\", contentString)));\n                return;\n            }\n\n            if (path.charAt(0) != '/') {\n                responseErr(\n                    TriRpcStatus.UNIMPLEMENTED.withDescription(\n                        \"Path must start with '/'. Request path: \" + path));\n                return;\n            }\n\n            String[] parts = path.split(\"/\");\n            if (parts.length != 3) {\n                responseErr(TriRpcStatus.UNIMPLEMENTED.withDescription(\"Bad path format:\" + path));\n                return;\n            }\n            String serviceName = parts[1];\n            String originalMethodName = parts[2];\n\n            Invoker<?> invoker = getInvoker(headers, serviceName);\n            if (invoker == null) {\n                responseErr(\n                    TriRpcStatus.UNIMPLEMENTED.withDescription(\"Service not found:\" + serviceName));\n                return;\n            }\n\n            DeCompressor deCompressor = DeCompressor.NONE;\n            CharSequence messageEncoding = headers.get(TripleHeaderEnum.GRPC_ENCODING.getHeader());\n            if (null != messageEncoding) {\n                String compressorStr = messageEncoding.toString();\n                if (!Identity.MESSAGE_ENCODING.equals(compressorStr)) {\n                    DeCompressor compressor = DeCompressor.getCompressor(frameworkModel,\n                        compressorStr);\n                    if (null == compressor) {\n                        responseErr(TriRpcStatus.fromCode(TriRpcStatus.Code.UNIMPLEMENTED.code)\n                            .withDescription(String.format(\"Grpc-encoding '%s' is not supported\",\n                                compressorStr)));\n                        return;\n                    }\n                    deCompressor = compressor;\n                }\n            }\n\n            try {\n                final TriDecoder.Listener listener = new ServerDecoderListener();\n                ServerStream.this.deframer = new TriDecoder(deCompressor, listener);\n            } catch (Throwable t) {\n                close(TriRpcStatus.INTERNAL.withCause(t), null);\n                return;\n            }\n\n            ServerCall call;\n            boolean hasStub = pathResolver.hasNativeStub(path);\n            if (hasStub) {\n                call = new StubServerCall(invoker, ServerStream.this, frameworkModel,\n                    acceptEncoding, serviceName, originalMethodName, executor);\n            } else {\n                call = new ReflectionServerCall(invoker, ServerStream.this, frameworkModel,\n                    acceptEncoding, serviceName, originalMethodName, filters, executor);\n            }\n            ServerStream.this.listener = call.startCall(headersToMap(headers));\n            if (listener == null) {\n                deframer.close();\n            }\n            if (endStream) {\n                deframer.close();\n            }\n        }\n\n\n        @Override\n        public void onData(ByteBuf data, boolean endStream) {\n            executor.execute(() -> doOnData(data, endStream));\n        }\n\n        private void doOnData(ByteBuf data, boolean endStream) {\n            deframer.deframe(data);\n            if (endStream) {\n                deframer.close();\n            }\n        }\n\n        @Override\n        public void cancelByRemote(TriRpcStatus status) {\n            executor.execute(() -> listener.cancel(status));\n        }\n\n        private class ServerDecoderListener implements TriDecoder.Listener {\n\n            @Override\n            public void onRawMessage(byte[] data) {\n                ServerStream.this.listener.onMessage(data);\n            }\n\n            @Override\n            public void close() {\n                if (ServerStream.this.listener != null) {\n                    ServerStream.this.listener.complete();\n                }\n            }\n        }\n    }\n\n\n}\n", "newFileContent": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.dubbo.rpc.protocol.tri.stream;\n\nimport org.apache.dubbo.rpc.TriRpcStatus;\n\nimport io.netty.util.concurrent.Future;\n\nimport java.util.Map;\n\n/**\n * ServerStream is used to send response to client and receive requests from client. {@link\n * Listener} is used to receive requests from client.\n */\npublic interface ServerStream extends Stream {\n\n    interface Listener extends Stream.Listener {\n\n        /**\n         * Callback when receive headers\n         *\n         * @param headers headers received from remote peer\n         */\n        void onHeader(Map<String, Object> headers);\n\n        /**\n         * Callback when no more data from client side\n         */\n        void onComplete();\n    }\n\n    /**\n     * Complete the stream, send response to client\n     *\n     * @param status      response status\n     * @param attachments response attachments\n     * @return a future that indicates the completion of send trailers\n     */\n    Future<?> complete(TriRpcStatus status, Map<String, Object> attachments);\n\n    /**\n     * Send message to client\n     *\n     * @param message      raw message\n     * @param compressFlag whether to compress the message\n     * @return a future that indicates the completion of send message\n     */\n    Future<?> sendMessage(byte[] message, int compressFlag);\n\n}\n", "patch": "@@ -17,380 +17,49 @@\n \n package org.apache.dubbo.rpc.protocol.tri.stream;\n \n-import org.apache.dubbo.common.URL;\n-import org.apache.dubbo.common.logger.Logger;\n-import org.apache.dubbo.common.logger.LoggerFactory;\n-import org.apache.dubbo.common.utils.StringUtils;\n-import org.apache.dubbo.rpc.HeaderFilter;\n-import org.apache.dubbo.rpc.Invoker;\n-import org.apache.dubbo.rpc.PathResolver;\n import org.apache.dubbo.rpc.TriRpcStatus;\n-import org.apache.dubbo.rpc.model.FrameworkModel;\n-import org.apache.dubbo.rpc.protocol.tri.ExceptionUtils;\n-import org.apache.dubbo.rpc.protocol.tri.TripleConstant;\n-import org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\n-import org.apache.dubbo.rpc.protocol.tri.call.ReflectionServerCall;\n-import org.apache.dubbo.rpc.protocol.tri.call.ServerCall;\n-import org.apache.dubbo.rpc.protocol.tri.call.StubServerCall;\n-import org.apache.dubbo.rpc.protocol.tri.command.DataQueueCommand;\n-import org.apache.dubbo.rpc.protocol.tri.command.HeaderQueueCommand;\n-import org.apache.dubbo.rpc.protocol.tri.command.TextDataQueueCommand;\n-import org.apache.dubbo.rpc.protocol.tri.compressor.DeCompressor;\n-import org.apache.dubbo.rpc.protocol.tri.compressor.Identity;\n-import org.apache.dubbo.rpc.protocol.tri.frame.Deframer;\n-import org.apache.dubbo.rpc.protocol.tri.frame.TriDecoder;\n-import org.apache.dubbo.rpc.protocol.tri.transport.AbstractH2TransportListener;\n-import org.apache.dubbo.rpc.protocol.tri.transport.H2TransportListener;\n-import org.apache.dubbo.rpc.protocol.tri.transport.WriteQueue;\n \n-import com.google.protobuf.Any;\n-import com.google.rpc.DebugInfo;\n-import com.google.rpc.Status;\n-import io.netty.buffer.ByteBuf;\n-import io.netty.channel.Channel;\n-import io.netty.handler.codec.http.HttpHeaderNames;\n-import io.netty.handler.codec.http.HttpMethod;\n-import io.netty.handler.codec.http.HttpResponseStatus;\n-import io.netty.handler.codec.http.HttpUtil;\n-import io.netty.handler.codec.http2.DefaultHttp2Headers;\n-import io.netty.handler.codec.http2.Http2Headers;\n import io.netty.util.concurrent.Future;\n-import io.netty.util.concurrent.GenericFutureListener;\n \n-import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n-import java.util.List;\n import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.Executor;\n \n-import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n-\n-public class ServerStream extends AbstractStream {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(ServerStream.class);\n-    public final ServerTransportObserver transportObserver = new ServerTransportObserver();\n-    private final WriteQueue writeQueue;\n-    private final PathResolver pathResolver;\n-    private final List<HeaderFilter> filters;\n-    private final String acceptEncoding;\n-    private boolean headerSent;\n-    private boolean trailersSent;\n-    private ServerStreamListener listener;\n-    private boolean closed;\n-    private final InetSocketAddress remoteAddress;\n-    private Deframer deframer;\n-\n-    public ServerStream(Channel channel,\n-        FrameworkModel frameworkModel,\n-        Executor executor,\n-        PathResolver pathResolver,\n-        String acceptEncoding,\n-        List<HeaderFilter> filters) {\n-        super(executor, frameworkModel);\n-        this.pathResolver = pathResolver;\n-        this.acceptEncoding = acceptEncoding;\n-        this.filters = filters;\n-        this.writeQueue = new WriteQueue(channel);\n-        this.remoteAddress = (InetSocketAddress) channel.remoteAddress();\n-    }\n-\n-    public SocketAddress remoteAddress() {\n-        return remoteAddress;\n-    }\n-\n-    private String getGrpcMessage(TriRpcStatus status) {\n-        if (StringUtils.isNotEmpty(status.description)) {\n-            return status.description;\n-        }\n-        return Optional.ofNullable(status.cause).map(Throwable::getMessage).orElse(\"unknown\");\n-    }\n-\n-    public void sendHeader(Http2Headers headers) {\n-        if (headerSent && trailersSent) {\n-            // todo handle this state\n-            return;\n-        }\n-        GenericFutureListener<Future<? super Void>> listener = future -> {\n-            if (future.isSuccess()) {\n-                return;\n-            }\n-            LOGGER.warn(\"Send response header failed:\" + headers, future.cause());\n-        };\n-        if (headerSent) {\n-            trailersSent = true;\n-            writeQueue.enqueue(HeaderQueueCommand.createHeaders(headers, true))\n-                .addListener(listener);\n-        } else {\n-            headerSent = true;\n-            writeQueue.enqueue(HeaderQueueCommand.createHeaders(headers, false))\n-                .addListener(listener);\n-        }\n-    }\n-\n-    public void sendHeaderWithEos(Http2Headers headers) {\n-        headerSent = true;\n-        sendHeader(headers);\n-    }\n-\n-    public void close(TriRpcStatus status, Map<String, Object> attachments) {\n-        if (closed) {\n-            return;\n-        }\n-        closed = true;\n-        final Http2Headers headers = getTrailers(status, attachments);\n-        sendHeaderWithEos(headers);\n-    }\n+/**\n+ * ServerStream is used to send response to client and receive requests from client. {@link\n+ * Listener} is used to receive requests from client.\n+ */\n+public interface ServerStream extends Stream {\n \n-    private Http2Headers getTrailers(TriRpcStatus rpcStatus, Map<String, Object> attachments) {\n-        DefaultHttp2Headers headers = new DefaultHttp2Headers();\n-        if (!headerSent) {\n-            headers.status(HttpResponseStatus.OK.codeAsText());\n-            headers.set(HttpHeaderNames.CONTENT_TYPE, TripleConstant.CONTENT_PROTO);\n-        }\n-        StreamUtils.convertAttachment(headers, attachments);\n-        headers.set(TripleHeaderEnum.STATUS_KEY.getHeader(), String.valueOf(rpcStatus.code.code));\n-        if (rpcStatus.isOk()) {\n-            return headers;\n-        }\n-        String grpcMessage = getGrpcMessage(rpcStatus);\n-        grpcMessage = TriRpcStatus.encodeMessage(TriRpcStatus.limitSizeTo1KB(grpcMessage));\n-        headers.set(TripleHeaderEnum.MESSAGE_KEY.getHeader(), grpcMessage);\n-        Status.Builder builder = Status.newBuilder().setCode(rpcStatus.code.code)\n-            .setMessage(grpcMessage);\n-        Throwable throwable = rpcStatus.cause;\n-        if (throwable == null) {\n-            Status status = builder.build();\n-            headers.set(TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader(),\n-                StreamUtils.encodeBase64ASCII(status.toByteArray()));\n-            return headers;\n-        }\n-        DebugInfo debugInfo = DebugInfo.newBuilder()\n-            .addAllStackEntries(ExceptionUtils.getStackFrameList(throwable, 6))\n-            // can not use now\n-            // .setDetail(throwable.getMessage())\n-            .build();\n-        builder.addDetails(Any.pack(debugInfo));\n-        Status status = builder.build();\n-        headers.set(TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader(),\n-            StreamUtils.encodeBase64ASCII(status.toByteArray()));\n-        return headers;\n-    }\n+    interface Listener extends Stream.Listener {\n \n-    @Override\n-    public void writeMessage(byte[] message, int compressed) {\n-        writeQueue.enqueue(DataQueueCommand.createGrpcCommand(message, false, compressed));\n-    }\n+        /**\n+         * Callback when receive headers\n+         *\n+         * @param headers headers received from remote peer\n+         */\n+        void onHeader(Map<String, Object> headers);\n \n-    @Override\n-    public void requestN(int n) {\n-        deframer.request(n);\n+        /**\n+         * Callback when no more data from client side\n+         */\n+        void onComplete();\n     }\n \n     /**\n-     * Error before create server stream, http plain text will be returned\n+     * Complete the stream, send response to client\n      *\n-     * @param code\n-     * @param status\n+     * @param status      response status\n+     * @param attachments response attachments\n+     * @return a future that indicates the completion of send trailers\n      */\n-    private void responsePlainTextError(int code, TriRpcStatus status) {\n-        Http2Headers headers = new DefaultHttp2Headers(true).status(String.valueOf(code))\n-            .setInt(TripleHeaderEnum.STATUS_KEY.getHeader(), status.code.code)\n-            .set(TripleHeaderEnum.MESSAGE_KEY.getHeader(), status.description)\n-            .set(TripleHeaderEnum.CONTENT_TYPE_KEY.getHeader(), TripleConstant.TEXT_PLAIN_UTF8);\n-        writeQueue.enqueue(HeaderQueueCommand.createHeaders(headers, false));\n-        writeQueue.enqueue(TextDataQueueCommand.createCommand(status.description, true));\n-    }\n+    Future<?> complete(TriRpcStatus status, Map<String, Object> attachments);\n \n     /**\n-     * Error in create stream, unsupported config or triple protocol error.\n+     * Send message to client\n      *\n-     * @param status\n+     * @param message      raw message\n+     * @param compressFlag whether to compress the message\n+     * @return a future that indicates the completion of send message\n      */\n-    private void responseErr(TriRpcStatus status) {\n-        Http2Headers trailers = new DefaultHttp2Headers().status(OK.codeAsText())\n-            .set(HttpHeaderNames.CONTENT_TYPE, TripleConstant.CONTENT_PROTO)\n-            .setInt(TripleHeaderEnum.STATUS_KEY.getHeader(), status.code.code)\n-            .set(TripleHeaderEnum.MESSAGE_KEY.getHeader(), status.toEncodedMessage());\n-        writeQueue.enqueue(HeaderQueueCommand.createHeaders(trailers, true));\n-    }\n-\n-\n-    private Invoker<?> getInvoker(Http2Headers headers, String serviceName) {\n-        final String version =\n-            headers.contains(TripleHeaderEnum.SERVICE_VERSION.getHeader()) ? headers.get(\n-                TripleHeaderEnum.SERVICE_VERSION.getHeader()).toString() : null;\n-        final String group =\n-            headers.contains(TripleHeaderEnum.SERVICE_GROUP.getHeader()) ? headers.get(\n-                TripleHeaderEnum.SERVICE_GROUP.getHeader()).toString() : null;\n-        final String key = URL.buildKey(serviceName, group, version);\n-        Invoker<?> invoker = pathResolver.resolve(key);\n-        if (invoker == null) {\n-            invoker = pathResolver.resolve(URL.buildKey(serviceName, group, \"1.0.0\"));\n-        }\n-        if (invoker == null) {\n-            invoker = pathResolver.resolve(serviceName);\n-        }\n-        return invoker;\n-    }\n-\n-    public class ServerTransportObserver extends AbstractH2TransportListener implements\n-        H2TransportListener {\n-\n-        /**\n-         * must starts from application/grpc\n-         */\n-        private boolean supportContentType(String contentType) {\n-            if (contentType == null) {\n-                return false;\n-            }\n-            return contentType.startsWith(TripleConstant.APPLICATION_GRPC);\n-        }\n-\n-        @Override\n-        public void onHeader(Http2Headers headers, boolean endStream) {\n-            executor.execute(() -> processHeader(headers, endStream));\n-        }\n-\n-        private void processHeader(Http2Headers headers, boolean endStream) {\n-            if (!HttpMethod.POST.asciiName().contentEquals(headers.method())) {\n-                responsePlainTextError(HttpResponseStatus.METHOD_NOT_ALLOWED.code(),\n-                    TriRpcStatus.INTERNAL.withDescription(\n-                        String.format(\"Method '%s' is not supported\", headers.method())));\n-                return;\n-            }\n-\n-            if (headers.path() == null) {\n-                responsePlainTextError(HttpResponseStatus.NOT_FOUND.code(),\n-                    TriRpcStatus.fromCode(TriRpcStatus.Code.UNIMPLEMENTED.code)\n-                        .withDescription(\"Expected path but is missing\"));\n-                return;\n-            }\n-\n-            final String path = headers.path().toString();\n-            if (path.charAt(0) != '/') {\n-                responsePlainTextError(HttpResponseStatus.NOT_FOUND.code(),\n-                    TriRpcStatus.fromCode(TriRpcStatus.Code.UNIMPLEMENTED.code)\n-                        .withDescription(String.format(\"Expected path to start with /: %s\", path)));\n-                return;\n-            }\n-\n-            final CharSequence contentType = HttpUtil.getMimeType(\n-                headers.get(HttpHeaderNames.CONTENT_TYPE));\n-            if (contentType == null) {\n-                responsePlainTextError(HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE.code(),\n-                    TriRpcStatus.fromCode(TriRpcStatus.Code.INTERNAL.code)\n-                        .withDescription(\"Content-Type is missing from the request\"));\n-                return;\n-            }\n-\n-            final String contentString = contentType.toString();\n-            if (!supportContentType(contentString)) {\n-                responsePlainTextError(HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE.code(),\n-                    TriRpcStatus.fromCode(TriRpcStatus.Code.INTERNAL.code)\n-                        .withDescription(\n-                            String.format(\"Content-Type '%s' is not supported\", contentString)));\n-                return;\n-            }\n-\n-            if (path.charAt(0) != '/') {\n-                responseErr(\n-                    TriRpcStatus.UNIMPLEMENTED.withDescription(\n-                        \"Path must start with '/'. Request path: \" + path));\n-                return;\n-            }\n-\n-            String[] parts = path.split(\"/\");\n-            if (parts.length != 3) {\n-                responseErr(TriRpcStatus.UNIMPLEMENTED.withDescription(\"Bad path format:\" + path));\n-                return;\n-            }\n-            String serviceName = parts[1];\n-            String originalMethodName = parts[2];\n-\n-            Invoker<?> invoker = getInvoker(headers, serviceName);\n-            if (invoker == null) {\n-                responseErr(\n-                    TriRpcStatus.UNIMPLEMENTED.withDescription(\"Service not found:\" + serviceName));\n-                return;\n-            }\n-\n-            DeCompressor deCompressor = DeCompressor.NONE;\n-            CharSequence messageEncoding = headers.get(TripleHeaderEnum.GRPC_ENCODING.getHeader());\n-            if (null != messageEncoding) {\n-                String compressorStr = messageEncoding.toString();\n-                if (!Identity.MESSAGE_ENCODING.equals(compressorStr)) {\n-                    DeCompressor compressor = DeCompressor.getCompressor(frameworkModel,\n-                        compressorStr);\n-                    if (null == compressor) {\n-                        responseErr(TriRpcStatus.fromCode(TriRpcStatus.Code.UNIMPLEMENTED.code)\n-                            .withDescription(String.format(\"Grpc-encoding '%s' is not supported\",\n-                                compressorStr)));\n-                        return;\n-                    }\n-                    deCompressor = compressor;\n-                }\n-            }\n-\n-            try {\n-                final TriDecoder.Listener listener = new ServerDecoderListener();\n-                ServerStream.this.deframer = new TriDecoder(deCompressor, listener);\n-            } catch (Throwable t) {\n-                close(TriRpcStatus.INTERNAL.withCause(t), null);\n-                return;\n-            }\n-\n-            ServerCall call;\n-            boolean hasStub = pathResolver.hasNativeStub(path);\n-            if (hasStub) {\n-                call = new StubServerCall(invoker, ServerStream.this, frameworkModel,\n-                    acceptEncoding, serviceName, originalMethodName, executor);\n-            } else {\n-                call = new ReflectionServerCall(invoker, ServerStream.this, frameworkModel,\n-                    acceptEncoding, serviceName, originalMethodName, filters, executor);\n-            }\n-            ServerStream.this.listener = call.startCall(headersToMap(headers));\n-            if (listener == null) {\n-                deframer.close();\n-            }\n-            if (endStream) {\n-                deframer.close();\n-            }\n-        }\n-\n-\n-        @Override\n-        public void onData(ByteBuf data, boolean endStream) {\n-            executor.execute(() -> doOnData(data, endStream));\n-        }\n-\n-        private void doOnData(ByteBuf data, boolean endStream) {\n-            deframer.deframe(data);\n-            if (endStream) {\n-                deframer.close();\n-            }\n-        }\n-\n-        @Override\n-        public void cancelByRemote(TriRpcStatus status) {\n-            executor.execute(() -> listener.cancel(status));\n-        }\n-\n-        private class ServerDecoderListener implements TriDecoder.Listener {\n-\n-            @Override\n-            public void onRawMessage(byte[] data) {\n-                ServerStream.this.listener.onMessage(data);\n-            }\n-\n-            @Override\n-            public void close() {\n-                if (ServerStream.this.listener != null) {\n-                    ServerStream.this.listener.complete();\n-                }\n-            }\n-        }\n-    }\n-\n+    Future<?> sendMessage(byte[] message, int compressFlag);\n \n }", "description": "\u6587\u4ef6\u884c\u6570\u4fee\u6539\u524d\u4e0d\u7b26\u5408\u89c4\u8303\uff0c\u4fee\u6539\u540e\u7b26\u5408\u89c4\u8303: 396 -> 65 \n"}, {"repository": "apache/dubbo", "commit_sha": "1add77ed6ec2872bb5cb8bbd69cdaea56f5b1acb", "mongoId": "63e2018785d52e6dee102537", "fileName": "dubbo-common/src/main/java/org/apache/dubbo/rpc/model/MethodDescriptor.java", "oldFileContent": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.model;\n\nimport org.apache.dubbo.common.constants.CommonConstants;\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.stream.StreamObserver;\nimport org.apache.dubbo.common.utils.ReflectUtils;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.Objects;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.stream.Stream;\n\nimport static org.apache.dubbo.common.constants.CommonConstants.$ECHO;\nimport static org.apache.dubbo.common.constants.CommonConstants.$INVOKE;\nimport static org.apache.dubbo.common.constants.CommonConstants.$INVOKE_ASYNC;\nimport static org.apache.dubbo.common.constants.CommonConstants.PROTOBUF_MESSAGE_CLASS_NAME;\n\npublic class MethodDescriptor {\n\n    private static final String GRPC_ASYNC_RETURN_CLASS = \"com.google.common.util.concurrent.ListenableFuture\";\n    private static final String TRI_ASYNC_RETURN_CLASS = \"java.util.concurrent.CompletableFuture\";\n    private static final String REACTOR_RETURN_CLASS = \"reactor.core.publisher.Mono\";\n    private static final String RX_RETURN_CLASS = \"io.reactivex.Single\";\n    private static final String GRPC_STREAM_CLASS = \"io.grpc.stub.StreamObserver\";\n\n    private static final Logger logger = LoggerFactory.getLogger(MethodDescriptor.class);\n    private final Method method;\n    private final String paramDesc;\n    /**\n     * duplicate filed as paramDesc, but with different format.\n     */\n    private final String[] compatibleParamSignatures;\n    private final Class<?>[] parameterClasses;\n    private final Class<?> returnClass;\n    private final Type[] returnTypes;\n    private final String methodName;\n    private final boolean generic;\n    private final boolean wrap;\n    private final RpcType rpcType;\n    private final ConcurrentMap<String, Object> attributeMap = new ConcurrentHashMap<>();\n\n    /**\n     * only for tri protocol\n     * support StreamObserver\n     */\n    private final Class<?>[] realParameterClasses;\n    private final Class<?> realReturnClass;\n\n    public MethodDescriptor(Method method) {\n        this.method = method;\n        this.methodName = method.getName();\n        Class<?>[] parameterTypes = method.getParameterTypes();\n        realParameterClasses = parameterTypes;\n        realReturnClass = method.getReturnType();\n        // bidirectional-stream: StreamObserver<Request> foo(StreamObserver<Response>)\n        if (parameterTypes.length == 1 && isStreamType(parameterTypes[0])) {\n            this.parameterClasses = new Class<?>[]{\n                    (Class<?>) ((ParameterizedType) method.getGenericReturnType()).getActualTypeArguments()[0]};\n            this.returnClass = (Class<?>) ((ParameterizedType) method.getGenericParameterTypes()[0])\n                    .getActualTypeArguments()[0];\n            this.rpcType = RpcType.BIDIRECTIONAL_STREAM;\n            // server-stream: void foo(Request, StreamObserver<Response>)\n        } else if (parameterTypes.length == 2 && method.getReturnType().equals(Void.TYPE)\n                && !isStreamType(parameterTypes[0]) && isStreamType(parameterTypes[1])) {\n            this.parameterClasses = method.getParameterTypes();\n            this.returnClass =\n                    (Class<?>) ((ParameterizedType) method.getGenericParameterTypes()[1]).getActualTypeArguments()[0];\n            this.rpcType = RpcType.SERVER_STREAM;\n        } else {\n            // unary: Response foo(Request)\n            this.parameterClasses = method.getParameterTypes();\n            this.returnClass = method.getReturnType();\n            this.rpcType = RpcType.UNARY;\n        }\n        this.wrap = needWrap();\n        Type[] returnTypesResult;\n        try {\n            returnTypesResult = ReflectUtils.getReturnTypes(method);\n        } catch (Throwable throwable) {\n            logger.error(\"fail to get return types. Method name: \" + methodName + \" Declaring class:\" + method.getDeclaringClass().getName(), throwable);\n            returnTypesResult = new Type[]{returnClass, returnClass};\n        }\n\n        this.returnTypes = returnTypesResult;\n        this.paramDesc = ReflectUtils.getDesc(parameterClasses);\n        this.compatibleParamSignatures = Stream.of(parameterClasses)\n                .map(Class::getName)\n                .toArray(String[]::new);\n        this.generic = (methodName.equals($INVOKE) || methodName.equals($INVOKE_ASYNC)) && parameterClasses.length == 3;\n    }\n\n    private static boolean isStreamType(Class<?> clz) {\n        return StreamObserver.class.isAssignableFrom(clz) || GRPC_STREAM_CLASS.equalsIgnoreCase(clz.getName());\n    }\n\n    public boolean isStream() {\n        return rpcType.equals(RpcType.SERVER_STREAM) || rpcType.equals(RpcType.BIDIRECTIONAL_STREAM) || rpcType.equals(RpcType.CLIENT_STREAM);\n    }\n\n    public boolean isServerStream() {\n        return RpcType.SERVER_STREAM.equals(rpcType);\n    }\n\n    public boolean isUnary() {\n        return rpcType.equals(RpcType.UNARY);\n    }\n\n    public boolean isNeedWrap() {\n        return wrap;\n    }\n\n    public RpcType getRpcType() {\n        return rpcType;\n    }\n\n    /**\n     * Determine if the request and response instance should be wrapped in Protobuf wrapper object\n     *\n     * @return true if the request and response object is not generated by protobuf\n     */\n    private boolean needWrap() {\n        // generic call must be wrapped\n        if (CommonConstants.$INVOKE.equals(methodName) || CommonConstants.$INVOKE_ASYNC.equals(methodName)) {\n            return true;\n        }\n        // echo must be wrapped\n        if ($ECHO.equals(methodName)) {\n            return true;\n        }\n        boolean returnClassProtobuf = isProtobufClass(returnClass);\n        // Response foo()\n        if (parameterClasses.length == 0) {\n            return !returnClassProtobuf;\n        }\n        int protobufParameterCount = 0;\n        int javaParameterCount = 0;\n        int streamParameterCount = 0;\n        boolean secondParameterStream = false;\n        // count normal and protobuf param\n        for (int i = 0; i < parameterClasses.length; i++) {\n            Class<?> parameterClass = parameterClasses[i];\n            if (isProtobufClass(parameterClass)) {\n                protobufParameterCount++;\n            } else {\n                if (isStreamType(parameterClass)) {\n                    if (i == 1) {\n                        secondParameterStream = true;\n                    }\n                    streamParameterCount++;\n                } else {\n                    javaParameterCount++;\n                }\n            }\n        }\n        // more than one stream param\n        if (streamParameterCount > 1) {\n            throw new IllegalStateException(\"method params error: more than one Stream params. method=\" + methodName);\n        }\n        // protobuf only support one param\n        if (protobufParameterCount >= 2) {\n            throw new IllegalStateException(\"method params error: more than one protobuf params. method=\" + methodName);\n        }\n        // server stream support one normal param and one stream param\n        if (streamParameterCount == 1) {\n            if (javaParameterCount + protobufParameterCount > 1) {\n                throw new IllegalStateException(\"method params error: server stream does not support more than one normal param.\" +\n                        \" method=\" + methodName);\n            }\n            // server stream: void foo(Request, StreamObserver<Response>)\n            if (!secondParameterStream) {\n                throw new IllegalStateException(\"method params error: server stream's second param must be StreamObserver.\" +\n                        \" method=\" + methodName);\n            }\n        }\n        if (isStream()) {\n            if (RpcType.SERVER_STREAM == rpcType) {\n                if (!secondParameterStream) {\n                    throw new IllegalStateException(\"method params error:server stream's second param must be StreamObserver.\" +\n                            \" method=\" + methodName);\n                }\n            }\n            // param type must be consistent\n            if (returnClassProtobuf) {\n                if (javaParameterCount > 0) {\n                    throw new IllegalStateException(\"method params error: both normal and protobuf param found. method=\" + methodName);\n                }\n            } else {\n                if (protobufParameterCount > 0) {\n                    throw new IllegalStateException(\"method params error method=\" + methodName);\n                }\n            }\n        } else {\n            if (streamParameterCount > 0) {\n                throw new IllegalStateException(\"method params error: unary method should not contain any StreamObserver.\" +\n                        \" method=\" + methodName);\n            }\n            if (protobufParameterCount > 0 && returnClassProtobuf) {\n                return false;\n            }\n            // handler reactor or rxjava only consider gen by proto\n            if (isMono(returnClass) || isRx(returnClass)) {\n                return false;\n            }\n            if (protobufParameterCount <= 0 && !returnClassProtobuf) {\n                return true;\n            }\n            // handle grpc stub only consider gen by proto\n            if (GRPC_ASYNC_RETURN_CLASS.equalsIgnoreCase(returnClass.getName()) && protobufParameterCount == 1) {\n                return false;\n            }\n            // handle dubbo generated method\n            if (TRI_ASYNC_RETURN_CLASS.equalsIgnoreCase(returnClass.getName())) {\n                Class<?> actualReturnClass =\n                        (Class<?>) ((ParameterizedType) method.getGenericReturnType()).getActualTypeArguments()[0];\n                boolean actualReturnClassProtobuf = isProtobufClass(actualReturnClass);\n                if (actualReturnClassProtobuf && protobufParameterCount == 1) {\n                    return false;\n                }\n                if (!actualReturnClassProtobuf && protobufParameterCount == 0) {\n                    return true;\n                }\n            }\n            // todo remove this in future\n            boolean ignore = checkNeedIgnore();\n            if (ignore) {\n                return protobufParameterCount != 1;\n            }\n            throw new IllegalStateException(\"method params error method=\" + methodName);\n        }\n        // java param should be wrapped\n        return javaParameterCount > 0;\n    }\n\n    /**\n     * fixme will produce error on grpc. but is harmless so ignore now\n     */\n    private boolean checkNeedIgnore() {\n        if (Iterator.class.isAssignableFrom(returnClass)) {\n            return true;\n        }\n        return false;\n    }\n\n    private boolean isMono(Class<?> clz) {\n        return REACTOR_RETURN_CLASS.equalsIgnoreCase(clz.getName());\n    }\n\n    private boolean isRx(Class<?> clz) {\n        return RX_RETURN_CLASS.equalsIgnoreCase(clz.getName());\n    }\n\n\n    public boolean isProtobufClass(Class<?> clazz) {\n        while (clazz != Object.class && clazz != null) {\n            Class<?>[] interfaces = clazz.getInterfaces();\n            if (interfaces.length > 0) {\n                for (Class<?> clazzInterface : interfaces) {\n                    if (PROTOBUF_MESSAGE_CLASS_NAME.equalsIgnoreCase(clazzInterface.getName())) {\n                        return true;\n                    }\n                }\n            }\n            clazz = clazz.getSuperclass();\n        }\n        return false;\n    }\n\n    public boolean matchParams(String params) {\n        return paramDesc.equalsIgnoreCase(params);\n    }\n\n    public Method getMethod() {\n        return method;\n    }\n\n    public String getParamDesc() {\n        return paramDesc;\n    }\n\n    public String[] getCompatibleParamSignatures() {\n        return compatibleParamSignatures;\n    }\n\n    public Class<?>[] getParameterClasses() {\n        return parameterClasses;\n    }\n\n    public Class<?> getReturnClass() {\n        return returnClass;\n    }\n\n    public Type[] getReturnTypes() {\n        return returnTypes;\n    }\n\n    public String getMethodName() {\n        return methodName;\n    }\n\n    public boolean isGeneric() {\n        return generic;\n    }\n\n    public void addAttribute(String key, Object value) {\n        this.attributeMap.put(key, value);\n    }\n\n    public Object getAttribute(String key) {\n        return this.attributeMap.get(key);\n    }\n\n\n    public Class<?>[] getRealParameterClasses() {\n        return realParameterClasses;\n    }\n\n    public Class<?> getRealReturnClass() {\n        return realReturnClass;\n    }\n\n    public enum RpcType {\n        UNARY, SERVER_STREAM, CLIENT_STREAM, BIDIRECTIONAL_STREAM\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        MethodDescriptor that = (MethodDescriptor) o;\n        return generic == that.generic\n            && wrap == that.wrap\n            && rpcType == that.rpcType\n            && Objects.equals(method, that.method)\n            && Objects.equals(paramDesc, that.paramDesc)\n            && Arrays.equals(compatibleParamSignatures, that.compatibleParamSignatures)\n            && Arrays.equals(parameterClasses, that.parameterClasses)\n            && Objects.equals(returnClass, that.returnClass)\n            && Arrays.equals(returnTypes, that.returnTypes)\n            && Objects.equals(methodName, that.methodName)\n            && Objects.equals(attributeMap, that.attributeMap)\n            && Arrays.equals(realParameterClasses, that.realParameterClasses)\n            && Objects.equals(realReturnClass, that.realReturnClass);\n    }\n\n    @Override\n    public int hashCode() {\n        int result = Objects.hash(method, paramDesc, returnClass, methodName, generic, wrap, rpcType, attributeMap, realReturnClass);\n        result = 31 * result + Arrays.hashCode(compatibleParamSignatures);\n        result = 31 * result + Arrays.hashCode(parameterClasses);\n        result = 31 * result + Arrays.hashCode(returnTypes);\n        result = 31 * result + Arrays.hashCode(realParameterClasses);\n        return result;\n    }\n}\n", "newFileContent": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.model;\n\nimport org.apache.dubbo.common.constants.CommonConstants;\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.stream.StreamObserver;\nimport org.apache.dubbo.common.utils.ReflectUtils;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.Objects;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.stream.Stream;\n\nimport static org.apache.dubbo.common.constants.CommonConstants.$ECHO;\nimport static org.apache.dubbo.common.constants.CommonConstants.$INVOKE;\nimport static org.apache.dubbo.common.constants.CommonConstants.$INVOKE_ASYNC;\nimport static org.apache.dubbo.common.constants.CommonConstants.PROTOBUF_MESSAGE_CLASS_NAME;\n\npublic class MethodDescriptor {\n\n    private static final String GRPC_ASYNC_RETURN_CLASS = \"com.google.common.util.concurrent.ListenableFuture\";\n    private static final String TRI_ASYNC_RETURN_CLASS = \"java.util.concurrent.CompletableFuture\";\n    private static final String REACTOR_RETURN_CLASS = \"reactor.core.publisher.Mono\";\n    private static final String RX_RETURN_CLASS = \"io.reactivex.Single\";\n    private static final String GRPC_STREAM_CLASS = \"io.grpc.stub.StreamObserver\";\n\n    private static final Logger logger = LoggerFactory.getLogger(MethodDescriptor.class);\n    protected final String methodName;\n    private final Method method;\n    private final String paramDesc;\n    /**\n     * duplicate filed as paramDesc, but with different format.\n     */\n    private final String[] compatibleParamSignatures;\n    private final Class<?>[] parameterClasses;\n    private final Class<?> returnClass;\n    private final Type[] returnTypes;\n    private final boolean generic;\n    private final boolean wrap;\n    private final ConcurrentMap<String, Object> attributeMap = new ConcurrentHashMap<>();\n\n    public MethodDescriptor(Method method) {\n        this(method, method.getParameterTypes(), method.getReturnType());\n    }\n\n    public MethodDescriptor(Method method, Class<?>[] parameterClasses, Class<?> returnClass) {\n        this.method = method;\n        this.methodName = method.getName();\n        this.parameterClasses = parameterClasses;\n        this.returnClass = returnClass;\n        Type[] returnTypesResult;\n        try {\n            returnTypesResult = ReflectUtils.getReturnTypes(method);\n        } catch (Throwable throwable) {\n            logger.error(\"fail to get return types. Method name: \" + methodName + \" Declaring class:\" + method.getDeclaringClass().getName(), throwable);\n            returnTypesResult = new Type[]{returnClass, returnClass};\n        }\n        this.returnTypes = returnTypesResult;\n        this.wrap = needWrap();\n        this.paramDesc = ReflectUtils.getDesc(parameterClasses);\n        this.compatibleParamSignatures = Stream.of(parameterClasses)\n            .map(Class::getName)\n            .toArray(String[]::new);\n        this.generic = (methodName.equals($INVOKE) || methodName.equals($INVOKE_ASYNC)) && parameterClasses.length == 3;\n    }\n\n    private static boolean isStreamType(Class<?> clz) {\n        return StreamObserver.class.isAssignableFrom(clz) || GRPC_STREAM_CLASS.equalsIgnoreCase(clz.getName());\n    }\n\n    public boolean isNeedWrap() {\n        return wrap;\n    }\n\n    /**\n     * Determine if the request and response instance should be wrapped in Protobuf wrapper object\n     *\n     * @return true if the request and response object is not generated by protobuf\n     */\n    protected boolean needWrap() {\n        // generic call must be wrapped\n        if (CommonConstants.$INVOKE.equals(methodName) || CommonConstants.$INVOKE_ASYNC.equals(methodName)) {\n            return true;\n        }\n        // echo must be wrapped\n        if ($ECHO.equals(methodName)) {\n            return true;\n        }\n        int protobufParameterCount = 0;\n        int javaParameterCount = 0;\n        for (Class<?> parameterClass : parameterClasses) {\n            if (isStreamType(parameterClass)) {\n                // more than one stream param\n                throw new IllegalStateException(\"method params error: more than one Stream params. method=\" + methodName);\n            }\n            if (isProtobufClass(parameterClass)) {\n                protobufParameterCount++;\n            } else {\n                javaParameterCount++;\n            }\n            if (protobufParameterCount > 0 && javaParameterCount > 0) {\n                throw new IllegalStateException(\"Bad method type, can not mix protobuf and normal pojo\");\n            }\n        }\n        // protobuf only support one param\n        if (protobufParameterCount >= 2) {\n            throw new IllegalStateException(\"method params error: more than one protobuf params. method=\" + methodName);\n        }\n\n        boolean returnClassProtobuf = isProtobufClass(returnClass);\n        if (protobufParameterCount > 0 && returnClassProtobuf) {\n            return false;\n        }\n        // handler reactor or rxjava only consider gen by proto\n        if (isMono(returnClass) || isRx(returnClass)) {\n            return false;\n        }\n        if (protobufParameterCount <= 0 && !returnClassProtobuf) {\n            return true;\n        }\n        // handle grpc stub only consider gen by proto\n        if (GRPC_ASYNC_RETURN_CLASS.equalsIgnoreCase(returnClass.getName()) && protobufParameterCount == 1) {\n            return false;\n        }\n        // handle dubbo generated method\n        if (TRI_ASYNC_RETURN_CLASS.equalsIgnoreCase(returnClass.getName())) {\n            Class<?> actualReturnClass =\n                (Class<?>) ((ParameterizedType) method.getGenericReturnType()).getActualTypeArguments()[0];\n            boolean actualReturnClassProtobuf = isProtobufClass(actualReturnClass);\n            if (actualReturnClassProtobuf && protobufParameterCount == 1) {\n                return false;\n            }\n            if (!actualReturnClassProtobuf && protobufParameterCount == 0) {\n                return true;\n            }\n        }\n\n        // todo remove this in future\n        boolean ignore = checkNeedIgnore();\n        if (ignore) {\n            return protobufParameterCount != 1;\n        }\n        if (!returnClassProtobuf || javaParameterCount > 0) {\n            throw new IllegalStateException(\"method params error method=\" + methodName);\n        }\n//            throw new IllegalStateException(\"method params error method=\" + methodName);\n        // java param should be wrapped\n        return javaParameterCount > 0;\n    }\n\n    /**\n     * fixme will produce error on grpc. but is harmless so ignore now\n     */\n    private boolean checkNeedIgnore() {\n        return Iterator.class.isAssignableFrom(returnClass);\n    }\n\n    private boolean isMono(Class<?> clz) {\n        return REACTOR_RETURN_CLASS.equalsIgnoreCase(clz.getName());\n    }\n\n    private boolean isRx(Class<?> clz) {\n        return RX_RETURN_CLASS.equalsIgnoreCase(clz.getName());\n    }\n\n    public boolean isProtobufClass(Class<?> clazz) {\n        while (clazz != Object.class && clazz != null) {\n            Class<?>[] interfaces = clazz.getInterfaces();\n            if (interfaces.length > 0) {\n                for (Class<?> clazzInterface : interfaces) {\n                    if (PROTOBUF_MESSAGE_CLASS_NAME.equalsIgnoreCase(clazzInterface.getName())) {\n                        return true;\n                    }\n                }\n            }\n            clazz = clazz.getSuperclass();\n        }\n        return false;\n    }\n\n    public boolean matchParams(String params) {\n        return paramDesc.equalsIgnoreCase(params);\n    }\n\n    public Method getMethod() {\n        return method;\n    }\n\n    public String getParamDesc() {\n        return paramDesc;\n    }\n\n    public String[] getCompatibleParamSignatures() {\n        return compatibleParamSignatures;\n    }\n\n    public Class<?>[] getParameterClasses() {\n        return parameterClasses;\n    }\n\n    public Class<?> getReturnClass() {\n        return returnClass;\n    }\n\n    public Type[] getReturnTypes() {\n        return returnTypes;\n    }\n\n    public String getMethodName() {\n        return methodName;\n    }\n\n    public boolean isGeneric() {\n        return generic;\n    }\n\n    public void addAttribute(String key, Object value) {\n        this.attributeMap.put(key, value);\n    }\n\n    public Object getAttribute(String key) {\n        return this.attributeMap.get(key);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        MethodDescriptor that = (MethodDescriptor) o;\n        return generic == that.generic\n            && wrap == that.wrap\n            && Objects.equals(method, that.method)\n            && Objects.equals(paramDesc, that.paramDesc)\n            && Arrays.equals(compatibleParamSignatures, that.compatibleParamSignatures)\n            && Arrays.equals(parameterClasses, that.parameterClasses)\n            && Objects.equals(returnClass, that.returnClass)\n            && Arrays.equals(returnTypes, that.returnTypes)\n            && Objects.equals(methodName, that.methodName)\n            && Objects.equals(attributeMap, that.attributeMap);\n    }\n\n    @Override\n    public int hashCode() {\n        int result = Objects.hash(method, paramDesc, returnClass, methodName, generic, wrap, attributeMap);\n        result = 31 * result + Arrays.hashCode(compatibleParamSignatures);\n        result = 31 * result + Arrays.hashCode(parameterClasses);\n        result = 31 * result + Arrays.hashCode(returnTypes);\n        return result;\n    }\n}\n", "patch": "@@ -46,6 +46,7 @@ public class MethodDescriptor {\n     private static final String GRPC_STREAM_CLASS = \"io.grpc.stub.StreamObserver\";\n \n     private static final Logger logger = LoggerFactory.getLogger(MethodDescriptor.class);\n+    protected final String methodName;\n     private final Method method;\n     private final String paramDesc;\n     /**\n@@ -55,92 +56,49 @@ public class MethodDescriptor {\n     private final Class<?>[] parameterClasses;\n     private final Class<?> returnClass;\n     private final Type[] returnTypes;\n-    private final String methodName;\n     private final boolean generic;\n     private final boolean wrap;\n-    private final RpcType rpcType;\n     private final ConcurrentMap<String, Object> attributeMap = new ConcurrentHashMap<>();\n \n-    /**\n-     * only for tri protocol\n-     * support StreamObserver\n-     */\n-    private final Class<?>[] realParameterClasses;\n-    private final Class<?> realReturnClass;\n-\n     public MethodDescriptor(Method method) {\n+        this(method, method.getParameterTypes(), method.getReturnType());\n+    }\n+\n+    public MethodDescriptor(Method method, Class<?>[] parameterClasses, Class<?> returnClass) {\n         this.method = method;\n         this.methodName = method.getName();\n-        Class<?>[] parameterTypes = method.getParameterTypes();\n-        realParameterClasses = parameterTypes;\n-        realReturnClass = method.getReturnType();\n-        // bidirectional-stream: StreamObserver<Request> foo(StreamObserver<Response>)\n-        if (parameterTypes.length == 1 && isStreamType(parameterTypes[0])) {\n-            this.parameterClasses = new Class<?>[]{\n-                    (Class<?>) ((ParameterizedType) method.getGenericReturnType()).getActualTypeArguments()[0]};\n-            this.returnClass = (Class<?>) ((ParameterizedType) method.getGenericParameterTypes()[0])\n-                    .getActualTypeArguments()[0];\n-            this.rpcType = RpcType.BIDIRECTIONAL_STREAM;\n-            // server-stream: void foo(Request, StreamObserver<Response>)\n-        } else if (parameterTypes.length == 2 && method.getReturnType().equals(Void.TYPE)\n-                && !isStreamType(parameterTypes[0]) && isStreamType(parameterTypes[1])) {\n-            this.parameterClasses = method.getParameterTypes();\n-            this.returnClass =\n-                    (Class<?>) ((ParameterizedType) method.getGenericParameterTypes()[1]).getActualTypeArguments()[0];\n-            this.rpcType = RpcType.SERVER_STREAM;\n-        } else {\n-            // unary: Response foo(Request)\n-            this.parameterClasses = method.getParameterTypes();\n-            this.returnClass = method.getReturnType();\n-            this.rpcType = RpcType.UNARY;\n-        }\n-        this.wrap = needWrap();\n+        this.parameterClasses = parameterClasses;\n+        this.returnClass = returnClass;\n         Type[] returnTypesResult;\n         try {\n             returnTypesResult = ReflectUtils.getReturnTypes(method);\n         } catch (Throwable throwable) {\n             logger.error(\"fail to get return types. Method name: \" + methodName + \" Declaring class:\" + method.getDeclaringClass().getName(), throwable);\n             returnTypesResult = new Type[]{returnClass, returnClass};\n         }\n-\n         this.returnTypes = returnTypesResult;\n+        this.wrap = needWrap();\n         this.paramDesc = ReflectUtils.getDesc(parameterClasses);\n         this.compatibleParamSignatures = Stream.of(parameterClasses)\n-                .map(Class::getName)\n-                .toArray(String[]::new);\n+            .map(Class::getName)\n+            .toArray(String[]::new);\n         this.generic = (methodName.equals($INVOKE) || methodName.equals($INVOKE_ASYNC)) && parameterClasses.length == 3;\n     }\n \n     private static boolean isStreamType(Class<?> clz) {\n         return StreamObserver.class.isAssignableFrom(clz) || GRPC_STREAM_CLASS.equalsIgnoreCase(clz.getName());\n     }\n \n-    public boolean isStream() {\n-        return rpcType.equals(RpcType.SERVER_STREAM) || rpcType.equals(RpcType.BIDIRECTIONAL_STREAM) || rpcType.equals(RpcType.CLIENT_STREAM);\n-    }\n-\n-    public boolean isServerStream() {\n-        return RpcType.SERVER_STREAM.equals(rpcType);\n-    }\n-\n-    public boolean isUnary() {\n-        return rpcType.equals(RpcType.UNARY);\n-    }\n-\n     public boolean isNeedWrap() {\n         return wrap;\n     }\n \n-    public RpcType getRpcType() {\n-        return rpcType;\n-    }\n-\n     /**\n      * Determine if the request and response instance should be wrapped in Protobuf wrapper object\n      *\n      * @return true if the request and response object is not generated by protobuf\n      */\n-    private boolean needWrap() {\n+    protected boolean needWrap() {\n         // generic call must be wrapped\n         if (CommonConstants.$INVOKE.equals(methodName) || CommonConstants.$INVOKE_ASYNC.equals(methodName)) {\n             return true;\n@@ -149,106 +107,64 @@ private boolean needWrap() {\n         if ($ECHO.equals(methodName)) {\n             return true;\n         }\n-        boolean returnClassProtobuf = isProtobufClass(returnClass);\n-        // Response foo()\n-        if (parameterClasses.length == 0) {\n-            return !returnClassProtobuf;\n-        }\n         int protobufParameterCount = 0;\n         int javaParameterCount = 0;\n-        int streamParameterCount = 0;\n-        boolean secondParameterStream = false;\n-        // count normal and protobuf param\n-        for (int i = 0; i < parameterClasses.length; i++) {\n-            Class<?> parameterClass = parameterClasses[i];\n+        for (Class<?> parameterClass : parameterClasses) {\n+            if (isStreamType(parameterClass)) {\n+                // more than one stream param\n+                throw new IllegalStateException(\"method params error: more than one Stream params. method=\" + methodName);\n+            }\n             if (isProtobufClass(parameterClass)) {\n                 protobufParameterCount++;\n             } else {\n-                if (isStreamType(parameterClass)) {\n-                    if (i == 1) {\n-                        secondParameterStream = true;\n-                    }\n-                    streamParameterCount++;\n-                } else {\n-                    javaParameterCount++;\n-                }\n+                javaParameterCount++;\n+            }\n+            if (protobufParameterCount > 0 && javaParameterCount > 0) {\n+                throw new IllegalStateException(\"Bad method type, can not mix protobuf and normal pojo\");\n             }\n-        }\n-        // more than one stream param\n-        if (streamParameterCount > 1) {\n-            throw new IllegalStateException(\"method params error: more than one Stream params. method=\" + methodName);\n         }\n         // protobuf only support one param\n         if (protobufParameterCount >= 2) {\n             throw new IllegalStateException(\"method params error: more than one protobuf params. method=\" + methodName);\n         }\n-        // server stream support one normal param and one stream param\n-        if (streamParameterCount == 1) {\n-            if (javaParameterCount + protobufParameterCount > 1) {\n-                throw new IllegalStateException(\"method params error: server stream does not support more than one normal param.\" +\n-                        \" method=\" + methodName);\n-            }\n-            // server stream: void foo(Request, StreamObserver<Response>)\n-            if (!secondParameterStream) {\n-                throw new IllegalStateException(\"method params error: server stream's second param must be StreamObserver.\" +\n-                        \" method=\" + methodName);\n-            }\n+\n+        boolean returnClassProtobuf = isProtobufClass(returnClass);\n+        if (protobufParameterCount > 0 && returnClassProtobuf) {\n+            return false;\n         }\n-        if (isStream()) {\n-            if (RpcType.SERVER_STREAM == rpcType) {\n-                if (!secondParameterStream) {\n-                    throw new IllegalStateException(\"method params error:server stream's second param must be StreamObserver.\" +\n-                            \" method=\" + methodName);\n-                }\n-            }\n-            // param type must be consistent\n-            if (returnClassProtobuf) {\n-                if (javaParameterCount > 0) {\n-                    throw new IllegalStateException(\"method params error: both normal and protobuf param found. method=\" + methodName);\n-                }\n-            } else {\n-                if (protobufParameterCount > 0) {\n-                    throw new IllegalStateException(\"method params error method=\" + methodName);\n-                }\n-            }\n-        } else {\n-            if (streamParameterCount > 0) {\n-                throw new IllegalStateException(\"method params error: unary method should not contain any StreamObserver.\" +\n-                        \" method=\" + methodName);\n-            }\n-            if (protobufParameterCount > 0 && returnClassProtobuf) {\n-                return false;\n-            }\n-            // handler reactor or rxjava only consider gen by proto\n-            if (isMono(returnClass) || isRx(returnClass)) {\n+        // handler reactor or rxjava only consider gen by proto\n+        if (isMono(returnClass) || isRx(returnClass)) {\n+            return false;\n+        }\n+        if (protobufParameterCount <= 0 && !returnClassProtobuf) {\n+            return true;\n+        }\n+        // handle grpc stub only consider gen by proto\n+        if (GRPC_ASYNC_RETURN_CLASS.equalsIgnoreCase(returnClass.getName()) && protobufParameterCount == 1) {\n+            return false;\n+        }\n+        // handle dubbo generated method\n+        if (TRI_ASYNC_RETURN_CLASS.equalsIgnoreCase(returnClass.getName())) {\n+            Class<?> actualReturnClass =\n+                (Class<?>) ((ParameterizedType) method.getGenericReturnType()).getActualTypeArguments()[0];\n+            boolean actualReturnClassProtobuf = isProtobufClass(actualReturnClass);\n+            if (actualReturnClassProtobuf && protobufParameterCount == 1) {\n                 return false;\n             }\n-            if (protobufParameterCount <= 0 && !returnClassProtobuf) {\n+            if (!actualReturnClassProtobuf && protobufParameterCount == 0) {\n                 return true;\n             }\n-            // handle grpc stub only consider gen by proto\n-            if (GRPC_ASYNC_RETURN_CLASS.equalsIgnoreCase(returnClass.getName()) && protobufParameterCount == 1) {\n-                return false;\n-            }\n-            // handle dubbo generated method\n-            if (TRI_ASYNC_RETURN_CLASS.equalsIgnoreCase(returnClass.getName())) {\n-                Class<?> actualReturnClass =\n-                        (Class<?>) ((ParameterizedType) method.getGenericReturnType()).getActualTypeArguments()[0];\n-                boolean actualReturnClassProtobuf = isProtobufClass(actualReturnClass);\n-                if (actualReturnClassProtobuf && protobufParameterCount == 1) {\n-                    return false;\n-                }\n-                if (!actualReturnClassProtobuf && protobufParameterCount == 0) {\n-                    return true;\n-                }\n-            }\n-            // todo remove this in future\n-            boolean ignore = checkNeedIgnore();\n-            if (ignore) {\n-                return protobufParameterCount != 1;\n-            }\n+        }\n+\n+        // todo remove this in future\n+        boolean ignore = checkNeedIgnore();\n+        if (ignore) {\n+            return protobufParameterCount != 1;\n+        }\n+        if (!returnClassProtobuf || javaParameterCount > 0) {\n             throw new IllegalStateException(\"method params error method=\" + methodName);\n         }\n+//            throw new IllegalStateException(\"method params error method=\" + methodName);\n         // java param should be wrapped\n         return javaParameterCount > 0;\n     }\n@@ -257,10 +173,7 @@ private boolean needWrap() {\n      * fixme will produce error on grpc. but is harmless so ignore now\n      */\n     private boolean checkNeedIgnore() {\n-        if (Iterator.class.isAssignableFrom(returnClass)) {\n-            return true;\n-        }\n-        return false;\n+        return Iterator.class.isAssignableFrom(returnClass);\n     }\n \n     private boolean isMono(Class<?> clz) {\n@@ -271,7 +184,6 @@ private boolean isRx(Class<?> clz) {\n         return RX_RETURN_CLASS.equalsIgnoreCase(clz.getName());\n     }\n \n-\n     public boolean isProtobufClass(Class<?> clazz) {\n         while (clazz != Object.class && clazz != null) {\n             Class<?>[] interfaces = clazz.getInterfaces();\n@@ -331,19 +243,6 @@ public Object getAttribute(String key) {\n         return this.attributeMap.get(key);\n     }\n \n-\n-    public Class<?>[] getRealParameterClasses() {\n-        return realParameterClasses;\n-    }\n-\n-    public Class<?> getRealReturnClass() {\n-        return realReturnClass;\n-    }\n-\n-    public enum RpcType {\n-        UNARY, SERVER_STREAM, CLIENT_STREAM, BIDIRECTIONAL_STREAM\n-    }\n-\n     @Override\n     public boolean equals(Object o) {\n         if (this == o) {\n@@ -355,26 +254,22 @@ public boolean equals(Object o) {\n         MethodDescriptor that = (MethodDescriptor) o;\n         return generic == that.generic\n             && wrap == that.wrap\n-            && rpcType == that.rpcType\n             && Objects.equals(method, that.method)\n             && Objects.equals(paramDesc, that.paramDesc)\n             && Arrays.equals(compatibleParamSignatures, that.compatibleParamSignatures)\n             && Arrays.equals(parameterClasses, that.parameterClasses)\n             && Objects.equals(returnClass, that.returnClass)\n             && Arrays.equals(returnTypes, that.returnTypes)\n             && Objects.equals(methodName, that.methodName)\n-            && Objects.equals(attributeMap, that.attributeMap)\n-            && Arrays.equals(realParameterClasses, that.realParameterClasses)\n-            && Objects.equals(realReturnClass, that.realReturnClass);\n+            && Objects.equals(attributeMap, that.attributeMap);\n     }\n \n     @Override\n     public int hashCode() {\n-        int result = Objects.hash(method, paramDesc, returnClass, methodName, generic, wrap, rpcType, attributeMap, realReturnClass);\n+        int result = Objects.hash(method, paramDesc, returnClass, methodName, generic, wrap, attributeMap);\n         result = 31 * result + Arrays.hashCode(compatibleParamSignatures);\n         result = 31 * result + Arrays.hashCode(parameterClasses);\n         result = 31 * result + Arrays.hashCode(returnTypes);\n-        result = 31 * result + Arrays.hashCode(realParameterClasses);\n         return result;\n     }\n }", "description": "\u6587\u4ef6\u884c\u6570\u4fee\u6539\u524d\u4e0d\u7b26\u5408\u89c4\u8303\uff0c\u4fee\u6539\u540e\u7b26\u5408\u89c4\u8303: 380 -> 275 \n"}, {"repository": "apache/dubbo", "commit_sha": "7a5d04a16923b2f3fbac943ca9254dc9f9debabd", "mongoId": "63e2018785d52e6dee102542", "fileName": "dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java", "oldFileContent": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.registry.client;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.utils.ConcurrentHashSet;\nimport org.apache.dubbo.metadata.MetadataInfo;\nimport org.apache.dubbo.metadata.report.MetadataReport;\nimport org.apache.dubbo.metadata.report.MetadataReportInstance;\nimport org.apache.dubbo.metadata.report.identifier.SubscriberMetadataIdentifier;\nimport org.apache.dubbo.registry.NotifyListener;\nimport org.apache.dubbo.registry.client.event.listener.ServiceInstancesChangedListener;\nimport org.apache.dubbo.registry.client.metadata.MetadataUtils;\nimport org.apache.dubbo.registry.client.metadata.ServiceInstanceMetadataUtils;\nimport org.apache.dubbo.registry.client.metadata.store.MetaCacheManager;\nimport org.apache.dubbo.rpc.model.ApplicationModel;\n\nimport java.util.List;\nimport java.util.Set;\n\nimport static org.apache.dubbo.common.constants.RegistryConstants.REGISTRY_CLUSTER_KEY;\nimport static org.apache.dubbo.metadata.RevisionResolver.EMPTY_REVISION;\nimport static org.apache.dubbo.registry.client.metadata.ServiceInstanceMetadataUtils.EXPORTED_SERVICES_REVISION_PROPERTY_NAME;\nimport static org.apache.dubbo.registry.client.metadata.ServiceInstanceMetadataUtils.isValidInstance;\nimport static org.apache.dubbo.registry.client.metadata.ServiceInstanceMetadataUtils.setMetadataStorageType;\n\n/**\n * Each service discovery is bond to one application.\n */\npublic abstract class AbstractServiceDiscovery implements ServiceDiscovery {\n    private final Logger logger = LoggerFactory.getLogger(AbstractServiceDiscovery.class);\n    private volatile boolean isDestroy;\n\n    protected final String serviceName;\n    protected volatile ServiceInstance serviceInstance;\n    protected volatile MetadataInfo metadataInfo;\n    protected MetadataReport metadataReport;\n    protected String metadataType;\n    protected MetaCacheManager metaCacheManager;\n    protected URL registryURL;\n\n    protected Set<ServiceInstancesChangedListener> instanceListeners = new ConcurrentHashSet<>();\n\n    protected ApplicationModel applicationModel;\n\n    public AbstractServiceDiscovery(ApplicationModel applicationModel, URL registryURL) {\n        this(applicationModel.getApplicationName(), registryURL);\n        this.applicationModel = applicationModel;\n        MetadataReportInstance metadataReportInstance = applicationModel.getBeanFactory().getBean(MetadataReportInstance.class);\n        metadataType = metadataReportInstance.getMetadataType();\n        this.metadataReport = metadataReportInstance.getMetadataReport(registryURL.getParameter(REGISTRY_CLUSTER_KEY));\n//        if (REMOTE_METADATA_STORAGE_TYPE.equals(metadataReportInstance.getMetadataType())) {\n//            this.metadataReport = metadataReportInstance.getMetadataReport(registryURL.getParameter(REGISTRY_CLUSTER_KEY));\n//        } else {\n//            this.metadataReport = metadataReportInstance.getNopMetadataReport();\n//        }\n    }\n\n    public AbstractServiceDiscovery(String serviceName, URL registryURL) {\n        this.applicationModel = ApplicationModel.defaultModel();\n        this.registryURL = registryURL;\n        this.serviceName = serviceName;\n        this.metadataInfo = new MetadataInfo(serviceName);\n        this.metaCacheManager = new MetaCacheManager(getCacheNameSuffix());\n    }\n\n    public synchronized void register() throws RuntimeException {\n        this.serviceInstance = createServiceInstance(this.metadataInfo);\n        if (!isValidInstance(this.serviceInstance)) {\n            logger.warn(\"No valid instance found, stop registering instance address to registry.\");\n            return;\n        }\n\n        // update origin metadataInfo's revision\n        this.metadataInfo.calAndGetRevision();\n        // clone metadataInfo to prevent metadataInfo changed during `calOrUpdateInstanceRevision` to `reportMetadata`\n        MetadataInfo copyOfMetaInfo = this.metadataInfo.clone();\n        boolean revisionUpdated = calOrUpdateInstanceRevision(this.serviceInstance, copyOfMetaInfo);\n        if (revisionUpdated) {\n            reportMetadata(copyOfMetaInfo);\n            doRegister(this.serviceInstance);\n        }\n    }\n\n    /**\n     * Update assumes that DefaultServiceInstance and its attributes will never get updated once created.\n     * Checking hasExportedServices() before registration guarantees that at least one service is ready for creating the\n     * instance.\n     */\n    @Override\n    public synchronized void update() throws RuntimeException {\n        if (isDestroy) {\n            return;\n        }\n\n        if (this.serviceInstance == null) {\n            this.serviceInstance = createServiceInstance(this.metadataInfo);\n        } else if (!isValidInstance(this.serviceInstance)) {\n            ServiceInstanceMetadataUtils.customizeInstance(this.serviceInstance, this.applicationModel);\n        }\n\n        if (!isValidInstance(this.serviceInstance)) {\n            return;\n        }\n\n\n        // update origin metadataInfo's revision\n        this.metadataInfo.calAndGetRevision();\n        // clone metadataInfo to prevent metadataInfo changed during `calOrUpdateInstanceRevision` to `reportMetadata`\n        MetadataInfo copyOfMetaInfo = this.metadataInfo.clone();\n        boolean revisionUpdated = calOrUpdateInstanceRevision(this.serviceInstance, copyOfMetaInfo);\n        if (revisionUpdated) {\n            logger.info(String.format(\"Metadata of instance changed, updating instance with revision %s.\", copyOfMetaInfo.getRevision()));\n            doUpdate(this.serviceInstance, copyOfMetaInfo);\n        }\n    }\n\n    @Override\n    public synchronized void unregister() throws RuntimeException {\n        // fixme, this metadata info might still being shared by other instances\n//        unReportMetadata(this.metadataInfo);\n        doUnregister(this.serviceInstance);\n    }\n\n    @Override\n    public final ServiceInstance getLocalInstance() {\n        return this.serviceInstance;\n    }\n\n    @Override\n    public MetadataInfo getLocalMetadata() {\n        return this.metadataInfo;\n    }\n\n    @Override\n    public MetadataInfo getRemoteMetadata(String revision, ServiceInstance instance) {\n        MetadataInfo metadata = metaCacheManager.get(revision);\n\n        if (metadata != null && metadata != MetadataInfo.EMPTY) {\n            // metadata loaded from cache\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"MetadataInfo for instance \" + instance.getAddress() + \"?revision=\" + revision\n                    + \"&cluster=\" + instance.getRegistryCluster() + \", \" + metadata);\n            }\n            return metadata;\n        }\n\n        // try to load metadata from remote.\n        int triedTimes = 0;\n        while (triedTimes < 3) {\n            metadata = MetadataUtils.getRemoteMetadata(revision, instance, metadataReport);\n\n            if (metadata != MetadataInfo.EMPTY) {// succeeded\n                metadata.init();\n                break;\n            } else {// failed\n                if (triedTimes > 0) {\n                    logger.info(\"Retry the \" + triedTimes + \" times to get metadata for instance \" + instance.getAddress() + \"?revision=\" + revision\n                        + \"&cluster=\" + instance.getRegistryCluster());\n                }\n                triedTimes++;\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                }\n            }\n        }\n\n        if (metadata == MetadataInfo.EMPTY) {\n            logger.error(\"Failed to get metadata for instance after 3 retries, \" + instance.getAddress() + \"?revision=\" + revision\n                + \"&cluster=\" + instance.getRegistryCluster());\n        } else {\n            metaCacheManager.put(revision, metadata);\n        }\n        return metadata;\n    }\n\n    @Override\n    public MetadataInfo getRemoteMetadata(String revision) {\n       return metaCacheManager.get(revision);\n    }\n\n    @Override\n    public final void destroy() throws Exception {\n        isDestroy = true;\n        metaCacheManager.destroy();\n        doDestroy();\n    }\n\n    @Override\n    public final boolean isDestroy() {\n        return isDestroy;\n    }\n\n    @Override\n    public void register(URL url) {\n        metadataInfo.addService(url);\n    }\n\n    @Override\n    public void unregister(URL url) {\n        metadataInfo.removeService(url);\n    }\n\n    @Override\n    public void subscribe(URL url, NotifyListener listener) {\n        metadataInfo.addSubscribedURL(url);\n    }\n\n    @Override\n    public void unsubscribe(URL url, NotifyListener listener) {\n        metadataInfo.removeSubscribedURL(url);\n    }\n\n    @Override\n    public List<URL> lookup(URL url) {\n       throw new UnsupportedOperationException(\"Service discovery implementation does not support lookup of url list.\");\n    }\n\n    protected void doUpdate(ServiceInstance serviceInstance, MetadataInfo metadataInfo) throws RuntimeException {\n\n        this.unregister();\n\n        reportMetadata(metadataInfo);\n        this.doRegister(serviceInstance);\n    }\n\n    @Override\n    public URL getUrl() {\n        return registryURL;\n    }\n\n    protected abstract void doRegister(ServiceInstance serviceInstance) throws RuntimeException;\n\n    protected abstract void doUnregister(ServiceInstance serviceInstance);\n\n    protected abstract void doDestroy() throws Exception;\n\n    protected ServiceInstance createServiceInstance(MetadataInfo metadataInfo) {\n        DefaultServiceInstance instance = new DefaultServiceInstance(serviceName, applicationModel);\n        instance.setServiceMetadata(metadataInfo);\n        setMetadataStorageType(instance, metadataType);\n        ServiceInstanceMetadataUtils.customizeInstance(instance, applicationModel);\n        return instance;\n    }\n\n    protected boolean calOrUpdateInstanceRevision(ServiceInstance instance, MetadataInfo metadataInfo) {\n        String existingInstanceRevision = instance.getMetadata().get(EXPORTED_SERVICES_REVISION_PROPERTY_NAME);\n        String newRevision = metadataInfo.calAndGetRevision();\n        if (!newRevision.equals(existingInstanceRevision)) {\n            if (EMPTY_REVISION.equals(newRevision)) {\n                return false;\n            }\n            instance.getMetadata().put(EXPORTED_SERVICES_REVISION_PROPERTY_NAME, metadataInfo.calAndGetRevision());\n            return true;\n        }\n        return false;\n    }\n\n    protected void reportMetadata(MetadataInfo metadataInfo) {\n        if (metadataReport != null) {\n            SubscriberMetadataIdentifier identifier = new SubscriberMetadataIdentifier(serviceName, metadataInfo.getRevision());\n            metadataReport.publishAppMetadata(identifier, metadataInfo);\n        }\n    }\n\n    protected void unReportMetadata(MetadataInfo metadataInfo) {\n        if (metadataReport != null) {\n            SubscriberMetadataIdentifier identifier = new SubscriberMetadataIdentifier(serviceName, metadataInfo.getRevision());\n            metadataReport.unPublishAppMetadata(identifier, metadataInfo);\n        }\n    }\n\n    private String getCacheNameSuffix() {\n        String name = this.getClass().getSimpleName();\n        int i = name.indexOf(ServiceDiscovery.class.getSimpleName());\n        if (i != -1) {\n            name = name.substring(0, i);\n        }\n        URL url = this.getUrl();\n        if (url != null) {\n           return name.toLowerCase() + url.getBackupAddress();\n        }\n        return name.toLowerCase();\n    }\n}\n", "newFileContent": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.registry.client;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.threadpool.manager.ExecutorRepository;\nimport org.apache.dubbo.common.utils.ConcurrentHashSet;\nimport org.apache.dubbo.metadata.MetadataInfo;\nimport org.apache.dubbo.metadata.report.MetadataReport;\nimport org.apache.dubbo.metadata.report.MetadataReportInstance;\nimport org.apache.dubbo.metadata.report.identifier.SubscriberMetadataIdentifier;\nimport org.apache.dubbo.registry.NotifyListener;\nimport org.apache.dubbo.registry.client.event.listener.ServiceInstancesChangedListener;\nimport org.apache.dubbo.registry.client.metadata.MetadataUtils;\nimport org.apache.dubbo.registry.client.metadata.ServiceInstanceMetadataUtils;\nimport org.apache.dubbo.registry.client.metadata.store.MetaCacheManager;\nimport org.apache.dubbo.rpc.model.ApplicationModel;\n\nimport java.util.List;\nimport java.util.Set;\n\nimport static org.apache.dubbo.common.constants.RegistryConstants.REGISTRY_CLUSTER_KEY;\nimport static org.apache.dubbo.metadata.RevisionResolver.EMPTY_REVISION;\nimport static org.apache.dubbo.registry.client.metadata.ServiceInstanceMetadataUtils.EXPORTED_SERVICES_REVISION_PROPERTY_NAME;\nimport static org.apache.dubbo.registry.client.metadata.ServiceInstanceMetadataUtils.isValidInstance;\nimport static org.apache.dubbo.registry.client.metadata.ServiceInstanceMetadataUtils.setMetadataStorageType;\n\n/**\n * Each service discovery is bond to one application.\n */\npublic abstract class AbstractServiceDiscovery implements ServiceDiscovery {\n    private final Logger logger = LoggerFactory.getLogger(AbstractServiceDiscovery.class);\n    private volatile boolean isDestroy;\n\n    protected final String serviceName;\n    protected volatile ServiceInstance serviceInstance;\n    protected volatile MetadataInfo metadataInfo;\n    protected MetadataReport metadataReport;\n    protected String metadataType;\n    protected final MetaCacheManager metaCacheManager;\n    protected URL registryURL;\n\n    protected Set<ServiceInstancesChangedListener> instanceListeners = new ConcurrentHashSet<>();\n\n    protected ApplicationModel applicationModel;\n\n    public AbstractServiceDiscovery(ApplicationModel applicationModel, URL registryURL) {\n        this(applicationModel.getApplicationName(), registryURL);\n        this.applicationModel = applicationModel;\n        MetadataReportInstance metadataReportInstance = applicationModel.getBeanFactory().getBean(MetadataReportInstance.class);\n        metadataType = metadataReportInstance.getMetadataType();\n        this.metadataReport = metadataReportInstance.getMetadataReport(registryURL.getParameter(REGISTRY_CLUSTER_KEY));\n//        if (REMOTE_METADATA_STORAGE_TYPE.equals(metadataReportInstance.getMetadataType())) {\n//            this.metadataReport = metadataReportInstance.getMetadataReport(registryURL.getParameter(REGISTRY_CLUSTER_KEY));\n//        } else {\n//            this.metadataReport = metadataReportInstance.getNopMetadataReport();\n//        }\n    }\n\n    public AbstractServiceDiscovery(String serviceName, URL registryURL) {\n        this.applicationModel = ApplicationModel.defaultModel();\n        this.registryURL = registryURL;\n        this.serviceName = serviceName;\n        this.metadataInfo = new MetadataInfo(serviceName);\n        this.metaCacheManager = new MetaCacheManager(getCacheNameSuffix(), applicationModel.getExtensionLoader(ExecutorRepository.class).getDefaultExtension().getCacheRefreshingScheduledExecutor());\n    }\n\n    public synchronized void register() throws RuntimeException {\n        this.serviceInstance = createServiceInstance(this.metadataInfo);\n        if (!isValidInstance(this.serviceInstance)) {\n            logger.warn(\"No valid instance found, stop registering instance address to registry.\");\n            return;\n        }\n\n        boolean revisionUpdated = calOrUpdateInstanceRevision(this.serviceInstance);\n        if (revisionUpdated) {\n            reportMetadata(this.metadataInfo);\n            doRegister(this.serviceInstance);\n        }\n    }\n\n    /**\n     * Update assumes that DefaultServiceInstance and its attributes will never get updated once created.\n     * Checking hasExportedServices() before registration guarantees that at least one service is ready for creating the\n     * instance.\n     */\n    @Override\n    public synchronized void update() throws RuntimeException {\n        if (isDestroy) {\n            return;\n        }\n\n        if (this.serviceInstance == null) {\n            this.serviceInstance = createServiceInstance(this.metadataInfo);\n        } else if (!isValidInstance(this.serviceInstance)) {\n            ServiceInstanceMetadataUtils.customizeInstance(this.serviceInstance, this.applicationModel);\n        }\n\n        if (!isValidInstance(this.serviceInstance)) {\n            return;\n        }\n\n        boolean revisionUpdated = calOrUpdateInstanceRevision(this.serviceInstance);\n        if (revisionUpdated) {\n            logger.info(String.format(\"Metadata of instance changed, updating instance with revision %s.\", this.serviceInstance.getServiceMetadata().getRevision()));\n            doUpdate(this.serviceInstance);\n        }\n    }\n\n    @Override\n    public synchronized void unregister() throws RuntimeException {\n        // fixme, this metadata info might still being shared by other instances\n//        unReportMetadata(this.metadataInfo);\n        doUnregister(this.serviceInstance);\n    }\n\n    @Override\n    public final ServiceInstance getLocalInstance() {\n        return this.serviceInstance;\n    }\n\n    @Override\n    public MetadataInfo getLocalMetadata() {\n        return this.metadataInfo;\n    }\n\n    @Override\n    public MetadataInfo getRemoteMetadata(String revision, ServiceInstance instance) {\n        MetadataInfo metadata = metaCacheManager.get(revision);\n\n        if (metadata != null && metadata != MetadataInfo.EMPTY) {\n            metadata.init();\n            // metadata loaded from cache\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"MetadataInfo for instance \" + instance.getAddress() + \"?revision=\" + revision\n                    + \"&cluster=\" + instance.getRegistryCluster() + \", \" + metadata);\n            }\n            return metadata;\n        }\n\n        synchronized (metaCacheManager) {\n            // try to load metadata from remote.\n            int triedTimes = 0;\n            while (triedTimes < 3) {\n                metadata = MetadataUtils.getRemoteMetadata(revision, instance, metadataReport);\n\n                if (metadata != MetadataInfo.EMPTY) {// succeeded\n                    metadata.init();\n                    break;\n                } else {// failed\n                    if (triedTimes > 0) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Retry the \" + triedTimes + \" times to get metadata for instance \" + instance.getAddress() + \"?revision=\" + revision\n                                + \"&cluster=\" + instance.getRegistryCluster());\n                        }\n                    }\n                    triedTimes++;\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                    }\n                }\n            }\n\n            if (metadata == MetadataInfo.EMPTY) {\n                logger.error(\"Failed to get metadata for instance after 3 retries, \" + instance.getAddress() + \"?revision=\" + revision\n                    + \"&cluster=\" + instance.getRegistryCluster());\n            } else {\n                metaCacheManager.put(revision, metadata);\n            }\n        }\n        return metadata;\n    }\n\n    @Override\n    public MetadataInfo getRemoteMetadata(String revision) {\n       return metaCacheManager.get(revision);\n    }\n\n    @Override\n    public final void destroy() throws Exception {\n        isDestroy = true;\n        metaCacheManager.destroy();\n        doDestroy();\n    }\n\n    @Override\n    public final boolean isDestroy() {\n        return isDestroy;\n    }\n\n    @Override\n    public void register(URL url) {\n        metadataInfo.addService(url);\n    }\n\n    @Override\n    public void unregister(URL url) {\n        metadataInfo.removeService(url);\n    }\n\n    @Override\n    public void subscribe(URL url, NotifyListener listener) {\n        metadataInfo.addSubscribedURL(url);\n    }\n\n    @Override\n    public void unsubscribe(URL url, NotifyListener listener) {\n        metadataInfo.removeSubscribedURL(url);\n    }\n\n    @Override\n    public List<URL> lookup(URL url) {\n       throw new UnsupportedOperationException(\"Service discovery implementation does not support lookup of url list.\");\n    }\n\n    protected void doUpdate(ServiceInstance serviceInstance) throws RuntimeException {\n\n        this.unregister();\n\n        reportMetadata(serviceInstance.getServiceMetadata());\n        this.doRegister(serviceInstance);\n    }\n\n    @Override\n    public URL getUrl() {\n        return registryURL;\n    }\n\n    protected abstract void doRegister(ServiceInstance serviceInstance) throws RuntimeException;\n\n    protected abstract void doUnregister(ServiceInstance serviceInstance);\n\n    protected abstract void doDestroy() throws Exception;\n\n    protected ServiceInstance createServiceInstance(MetadataInfo metadataInfo) {\n        DefaultServiceInstance instance = new DefaultServiceInstance(serviceName, applicationModel);\n        instance.setServiceMetadata(metadataInfo);\n        setMetadataStorageType(instance, metadataType);\n        ServiceInstanceMetadataUtils.customizeInstance(instance, applicationModel);\n        return instance;\n    }\n\n    protected boolean calOrUpdateInstanceRevision(ServiceInstance instance) {\n        String existingInstanceRevision = instance.getMetadata().get(EXPORTED_SERVICES_REVISION_PROPERTY_NAME);\n        MetadataInfo metadataInfo = instance.getServiceMetadata();\n        String newRevision = metadataInfo.calAndGetRevision();\n        if (!newRevision.equals(existingInstanceRevision)) {\n            if (EMPTY_REVISION.equals(newRevision)) {\n                return false;\n            }\n            instance.getMetadata().put(EXPORTED_SERVICES_REVISION_PROPERTY_NAME, metadataInfo.getRevision());\n            return true;\n        }\n        return false;\n    }\n\n    protected void reportMetadata(MetadataInfo metadataInfo) {\n        if (metadataReport != null) {\n            SubscriberMetadataIdentifier identifier = new SubscriberMetadataIdentifier(serviceName, metadataInfo.getRevision());\n            metadataReport.publishAppMetadata(identifier, metadataInfo);\n        }\n    }\n\n    protected void unReportMetadata(MetadataInfo metadataInfo) {\n        if (metadataReport != null) {\n            SubscriberMetadataIdentifier identifier = new SubscriberMetadataIdentifier(serviceName, metadataInfo.getRevision());\n            metadataReport.unPublishAppMetadata(identifier, metadataInfo);\n        }\n    }\n\n    private String getCacheNameSuffix() {\n        String name = this.getClass().getSimpleName();\n        int i = name.indexOf(ServiceDiscovery.class.getSimpleName());\n        if (i != -1) {\n            name = name.substring(0, i);\n        }\n        URL url = this.getUrl();\n        if (url != null) {\n           return name.toLowerCase() + url.getBackupAddress();\n        }\n        return name.toLowerCase();\n    }\n}\n", "patch": "@@ -19,6 +19,7 @@\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.threadpool.manager.ExecutorRepository;\n import org.apache.dubbo.common.utils.ConcurrentHashSet;\n import org.apache.dubbo.metadata.MetadataInfo;\n import org.apache.dubbo.metadata.report.MetadataReport;\n@@ -52,7 +53,7 @@ public abstract class AbstractServiceDiscovery implements ServiceDiscovery {\n     protected volatile MetadataInfo metadataInfo;\n     protected MetadataReport metadataReport;\n     protected String metadataType;\n-    protected MetaCacheManager metaCacheManager;\n+    protected final MetaCacheManager metaCacheManager;\n     protected URL registryURL;\n \n     protected Set<ServiceInstancesChangedListener> instanceListeners = new ConcurrentHashSet<>();\n@@ -77,7 +78,7 @@ public AbstractServiceDiscovery(String serviceName, URL registryURL) {\n         this.registryURL = registryURL;\n         this.serviceName = serviceName;\n         this.metadataInfo = new MetadataInfo(serviceName);\n-        this.metaCacheManager = new MetaCacheManager(getCacheNameSuffix());\n+        this.metaCacheManager = new MetaCacheManager(getCacheNameSuffix(), applicationModel.getExtensionLoader(ExecutorRepository.class).getDefaultExtension().getCacheRefreshingScheduledExecutor());\n     }\n \n     public synchronized void register() throws RuntimeException {\n@@ -87,13 +88,9 @@ public synchronized void register() throws RuntimeException {\n             return;\n         }\n \n-        // update origin metadataInfo's revision\n-        this.metadataInfo.calAndGetRevision();\n-        // clone metadataInfo to prevent metadataInfo changed during `calOrUpdateInstanceRevision` to `reportMetadata`\n-        MetadataInfo copyOfMetaInfo = this.metadataInfo.clone();\n-        boolean revisionUpdated = calOrUpdateInstanceRevision(this.serviceInstance, copyOfMetaInfo);\n+        boolean revisionUpdated = calOrUpdateInstanceRevision(this.serviceInstance);\n         if (revisionUpdated) {\n-            reportMetadata(copyOfMetaInfo);\n+            reportMetadata(this.metadataInfo);\n             doRegister(this.serviceInstance);\n         }\n     }\n@@ -119,15 +116,10 @@ public synchronized void update() throws RuntimeException {\n             return;\n         }\n \n-\n-        // update origin metadataInfo's revision\n-        this.metadataInfo.calAndGetRevision();\n-        // clone metadataInfo to prevent metadataInfo changed during `calOrUpdateInstanceRevision` to `reportMetadata`\n-        MetadataInfo copyOfMetaInfo = this.metadataInfo.clone();\n-        boolean revisionUpdated = calOrUpdateInstanceRevision(this.serviceInstance, copyOfMetaInfo);\n+        boolean revisionUpdated = calOrUpdateInstanceRevision(this.serviceInstance);\n         if (revisionUpdated) {\n-            logger.info(String.format(\"Metadata of instance changed, updating instance with revision %s.\", copyOfMetaInfo.getRevision()));\n-            doUpdate(this.serviceInstance, copyOfMetaInfo);\n+            logger.info(String.format(\"Metadata of instance changed, updating instance with revision %s.\", this.serviceInstance.getServiceMetadata().getRevision()));\n+            doUpdate(this.serviceInstance);\n         }\n     }\n \n@@ -153,6 +145,7 @@ public MetadataInfo getRemoteMetadata(String revision, ServiceInstance instance)\n         MetadataInfo metadata = metaCacheManager.get(revision);\n \n         if (metadata != null && metadata != MetadataInfo.EMPTY) {\n+            metadata.init();\n             // metadata loaded from cache\n             if (logger.isDebugEnabled()) {\n                 logger.debug(\"MetadataInfo for instance \" + instance.getAddress() + \"?revision=\" + revision\n@@ -161,32 +154,36 @@ public MetadataInfo getRemoteMetadata(String revision, ServiceInstance instance)\n             return metadata;\n         }\n \n-        // try to load metadata from remote.\n-        int triedTimes = 0;\n-        while (triedTimes < 3) {\n-            metadata = MetadataUtils.getRemoteMetadata(revision, instance, metadataReport);\n-\n-            if (metadata != MetadataInfo.EMPTY) {// succeeded\n-                metadata.init();\n-                break;\n-            } else {// failed\n-                if (triedTimes > 0) {\n-                    logger.info(\"Retry the \" + triedTimes + \" times to get metadata for instance \" + instance.getAddress() + \"?revision=\" + revision\n-                        + \"&cluster=\" + instance.getRegistryCluster());\n-                }\n-                triedTimes++;\n-                try {\n-                    Thread.sleep(1000);\n-                } catch (InterruptedException e) {\n+        synchronized (metaCacheManager) {\n+            // try to load metadata from remote.\n+            int triedTimes = 0;\n+            while (triedTimes < 3) {\n+                metadata = MetadataUtils.getRemoteMetadata(revision, instance, metadataReport);\n+\n+                if (metadata != MetadataInfo.EMPTY) {// succeeded\n+                    metadata.init();\n+                    break;\n+                } else {// failed\n+                    if (triedTimes > 0) {\n+                        if (logger.isDebugEnabled()) {\n+                            logger.debug(\"Retry the \" + triedTimes + \" times to get metadata for instance \" + instance.getAddress() + \"?revision=\" + revision\n+                                + \"&cluster=\" + instance.getRegistryCluster());\n+                        }\n+                    }\n+                    triedTimes++;\n+                    try {\n+                        Thread.sleep(1000);\n+                    } catch (InterruptedException e) {\n+                    }\n                 }\n             }\n-        }\n \n-        if (metadata == MetadataInfo.EMPTY) {\n-            logger.error(\"Failed to get metadata for instance after 3 retries, \" + instance.getAddress() + \"?revision=\" + revision\n-                + \"&cluster=\" + instance.getRegistryCluster());\n-        } else {\n-            metaCacheManager.put(revision, metadata);\n+            if (metadata == MetadataInfo.EMPTY) {\n+                logger.error(\"Failed to get metadata for instance after 3 retries, \" + instance.getAddress() + \"?revision=\" + revision\n+                    + \"&cluster=\" + instance.getRegistryCluster());\n+            } else {\n+                metaCacheManager.put(revision, metadata);\n+            }\n         }\n         return metadata;\n     }\n@@ -233,11 +230,11 @@ public List<URL> lookup(URL url) {\n        throw new UnsupportedOperationException(\"Service discovery implementation does not support lookup of url list.\");\n     }\n \n-    protected void doUpdate(ServiceInstance serviceInstance, MetadataInfo metadataInfo) throws RuntimeException {\n+    protected void doUpdate(ServiceInstance serviceInstance) throws RuntimeException {\n \n         this.unregister();\n \n-        reportMetadata(metadataInfo);\n+        reportMetadata(serviceInstance.getServiceMetadata());\n         this.doRegister(serviceInstance);\n     }\n \n@@ -260,14 +257,15 @@ protected ServiceInstance createServiceInstance(MetadataInfo metadataInfo) {\n         return instance;\n     }\n \n-    protected boolean calOrUpdateInstanceRevision(ServiceInstance instance, MetadataInfo metadataInfo) {\n+    protected boolean calOrUpdateInstanceRevision(ServiceInstance instance) {\n         String existingInstanceRevision = instance.getMetadata().get(EXPORTED_SERVICES_REVISION_PROPERTY_NAME);\n+        MetadataInfo metadataInfo = instance.getServiceMetadata();\n         String newRevision = metadataInfo.calAndGetRevision();\n         if (!newRevision.equals(existingInstanceRevision)) {\n             if (EMPTY_REVISION.equals(newRevision)) {\n                 return false;\n             }\n-            instance.getMetadata().put(EXPORTED_SERVICES_REVISION_PROPERTY_NAME, metadataInfo.calAndGetRevision());\n+            instance.getMetadata().put(EXPORTED_SERVICES_REVISION_PROPERTY_NAME, metadataInfo.getRevision());\n             return true;\n         }\n         return false;", "description": "\u6587\u4ef6\u884c\u6570\u4fee\u6539\u524d\u4e0d\u7b26\u5408\u89c4\u8303\uff0c\u4fee\u6539\u540e\u7b26\u5408\u89c4\u8303: 302 -> 300 \n"}]